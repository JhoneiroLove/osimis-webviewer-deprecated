/**
 * webViewer - webViewer Project Generated from OsimisAngular
 * @authors 
 * @version v0.0.1
 * @link 
 * @license 
 */
!function(){"use strict";var n="0.2.9";angular.module("webviewer",["ngResource","ngSanitize","mgcrea.ngStrap","ngRangeFilter","debounce"]).constant("$",window.$).constant("_",window._).constant("pako",window.pako).constant("JpegImage",window.JpegImage).constant("hamster",window.Hamster).constant("cornerstone",window.cornerstone).constant("cornerstoneTools",window.cornerstoneTools).provider("wvConfig",function(){var e={version:n,orthancApiURL:"",webviewerApiURL:"web-viewer",defaultCompression:"95"};this.setApiURL=function(n){"/"===n.substr(-1)&&(n=n.substr(0,n.length-1)),e.orthancApiURL=n,e.webviewerApiURL=n+"/web-viewer"},this.$get=function(){return e}})}(),function(){"use strict";function n(){function n(n){n=_.flatten(n),this._annotations=n||[]}return n.prototype.toArray=function(){return this._annotations},n.prototype.filterByType=function(e){var t=this._annotations.filter(function(n){return n.type===e});return new n(t)},n.prototype.filterByImageId=function(e){var t=this._annotations.filter(function(n){return n.imageId===e});return new n(t)},n.prototype.getImageIds=function(){return this._annotations.reduce(function(n,e){var t=e.imageId;return-1===n.indexOf(t)&&n.push(t),n},[])},n.prototype.getTypes=function(){return this._annotations.reduce(function(n,e){var t=e.type;return-1===n.indexOf(t)&&n.push(t),n},[])},n.prototype.mapByImageIds=function(e){var t=this._annotations.reduce(function(n,e){var t=e.imageId;return n.hasOwnProperty(t)||(n[t]=[]),n[t].push(e),n},{}),i=_(t).mapValues(function(e){return new n(e)}).value();return _(i).map(e).value()},n.prototype.hasType=function(n){return this._annotations.reduce(function(e,t){return e||t.type===n},!1)},n}angular.module("webviewer").factory("WvAnnotationGroup",n)}(),function(){"use strict";function n(n){function e(n){n=_.cloneDeep(n),i[n.type]=i[n.type]||{},i[n.type][n.imageId]=n,(!n.data||"undefined"!=typeof n.data.length&&0===n.data.length)&&delete i[n.type][n.imageId],r.onAnnotationChanged.trigger(n)}function t(n,e){return e?i[e]&&_.cloneDeep(i[e][n]):_(i).flatMap(function(n){return _.values(n)}).filter(function(e){return e.imageId===n}).cloneDeep()}var i={},r={set:e,getByImageId:t,onAnnotationChanged:new osimis.Listener};return r}n.$inject=["WvAnnotationValueObject"],angular.module("webviewer").factory("wvAnnotationManager",n)}(),function(){"use strict";function n(){function n(n,e,t){this.type=n,this.imageId=e,this.data=t}return n}angular.module("webviewer").factory("WvAnnotationValueObject",n)}(),function(){"use strict";function n(n,e){function t(n,t,i,r,o){i.imageId=n,i.qualityLevel=t;var a=i.width/i.originalWidth;i.columnPixelSpacing=i.columnPixelSpacing/a,i.rowPixelSpacing=i.rowPixelSpacing/a,i.color?i.render=e.renderColorImage:i.render=e.renderGrayscaleImage;var s=null;switch(o){case"Uint8":s=new Uint8Array(r);break;case"Int8":s=new Int8Array(r);break;case"Uint16":s=new Uint16Array(r);break;case"Int16":s=new Int16Array(r);break;default:throw new Error("Unexpected array binary format")}return i.getPixelData=function(){return s},i}var i={process:t};return i}n.$inject=["wvConfig","cornerstone"],angular.module("webviewer").factory("wvCornerstoneImageAdapter",n)}(),function(){"use strict";function n(n,e,t,i){function r(e,t,r){if(p[e]||(p[e]={}),u[e]||(u[e]={}),!u[e][t]){var o=h.queueTask({type:"getBinary",id:e,quality:t}).then(function(r){if(!f[e][t])return delete f[e][t],delete u[e][t],"undefined"!=typeof p[e][t]&&delete p[e][t],n.reject("aborted");var o=i.process(e,t,r.cornerstoneMetaData,r.pixelBuffer,r.pixelBufferFormat);return p[e][t]=!0,u[e][t].isLoaded=!0,u[e][t].size=r.pixelBuffer.byteLength,d.onBinaryLoaded.trigger(e,t,o),o}).then(null,function(i){return delete f[e][t],delete u[e][t],"undefined"!=typeof p[e][t]&&delete p[e][t],n.reject(i)});u[e][t]=new osimis.ImageBinaryRequest(e,t,o)}return u[e][t].pushPriority(r),f[e]||(f[e]={}),f[e][t]||(f[e][t]=0),++f[e][t],u[e][t].promise}function o(n,e,t){if(!f.hasOwnProperty(n)||!f[n].hasOwnProperty(e)||f[n][e]<1)throw new Error("Free uncached image binary.");--f[n][e],u[n][e]&&u[n][e].popPriority(t),0!==f[n][e]||p[n][e]||(h.abortTask({type:"getBinary",id:n,quality:e}),u[n][e]=null,delete u[n][e],"undefined"!=typeof p[n][e]&&delete p[n][e],delete f[n][e],d.onBinaryUnLoaded.trigger(n,e))}function a(n,e){return r(n,e,0)}function s(n,e){return o(n,e,0)}function c(n){var e=[];return e=p[n]?_.keys(p[n]).map(function(n){return+n}):[]}function l(n){if(!p[n])return null;var e=_.max(_.keys(p[n]));return e}var d={get:a,free:s,listCachedBinaries:c,getBestQualityInCache:l,onBinaryLoaded:new osimis.Listener,onBinaryUnLoaded:new osimis.Listener,requestLoading:r,abortLoading:o},u={},p={},f={},h=new window.osimis.WorkerPool({path:URL.createObjectURL(new Blob(['/**\n *\n * Worker that retrieve and process image binaries.\n *\n * Can only process one request at a time.\n * User has to wait request end (or abort it using a command) to send a new one, otherwise it\'ll bug.\n *\n */\n\n\'use strict\';\n\n// @todo move jpgjs & pngjs out of bower_components\n\n(function(module) {\n\n	function KLVReader(binary) {\n	    this._binary = binary;\n		this._dataview = new DataView(this._binary);\n\n		this._keys = {} // for each key: pointer to binary address\n		this._parseFile();\n	}\n\n	KLVReader.prototype.getUInt = function(key) {\n		var binary = this._keys[key];\n		var dataView = new DataView(binary.buffer);\n		if (dataView.byteLength === 1) {\n			return dataView.getUint8(0, false);\n		}\n		else if (dataView.byteLength === 2) {\n			return dataView.getUint16(0, false);\n		}\n		else if (dataView.byteLength === 4) {\n			return dataView.getUint32(0, false);\n		}\n		else {\n			// @todo throw exception\n			return this._keys[key];\n		}\n	};\n\n	KLVReader.prototype.getInt = function(key) {\n		var binary = this._keys[key];\n		var dataView = new DataView(binary.buffer);\n		if (dataView.byteLength === 1) {\n			return dataView.getInt8(0, false);\n		}\n		else if (dataView.byteLength === 2) {\n			return dataView.getInt16(0, false);\n		}\n		else if (dataView.byteLength === 4) {\n			return dataView.getInt32(0, false);\n		}\n		else {\n			// @todo throw exception\n			return this._keys[key];\n		}\n	};\n\n	KLVReader.prototype.getFloat = function(key) {\n		var binary = this._keys[key];\n		var dataView = new DataView(binary.buffer);\n		return dataView.getFloat32(0, false);\n	};\n\n	KLVReader.prototype.getBinary = function(key) {\n		return this._keys[key];\n	};\n\n	KLVReader.prototype.getString = function(key) {\n	    var binary = this._keys[key];\n	    var str = String.fromCharCode.apply(String, binary);\n	    return str;\n	};\n\n	KLVReader.prototype.getJSON = function(key) {\n	    var str = this.getString(key);\n	    var json = JSON.parse(str);\n		return json;\n	};\n\n	KLVReader.prototype._parseFile = function() {\n		this._keys = {}\n\n		// parse the file\n		for (var offset = 0; offset < this._dataview.byteLength - 1;) {\n			var key = this._dataview.getUint32(offset, false);\n			offset += 4;\n\n			var length = this._dataview.getUint32(offset, false);\n			offset += 4;\n\n			var value = new Uint8ClampedArray(this._binary.slice(offset, offset + length));\n			offset += length;\n\n			this._keys[key] = value;\n		}\n	}\n\n	module.KLVReader = KLVReader;\n\n})(typeof WorkerGlobalScope !== \'undefined\' ? WorkerGlobalScope : window);;\n/**\n * @license\n * Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction loadURLasArrayBuffer(path, callback) {\n    if (path.indexOf("data:") === 0) {\n        var offset = path.indexOf("base64,") + 7;\n        var data = atob(path.substring(offset));\n        var arr = new Uint8Array(data.length);\n        for (var i = data.length - 1; i >= 0; i--) {\n            arr[i] = data.charCodeAt(i);\n        }\n        callback(arr.buffer);\n        return;\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open("GET", path, true);\n    xhr.responseType = "arraybuffer";\n    xhr.onload = function() {\n        callback(xhr.response);\n    };\n    xhr.send(null);\n}\n\nvar JpegImage = function jpegImage() {\n    function JpegImage() {\n        this._src = null;\n        this._parser = new PDFJS.JpegImage();\n        this.onload = null;\n    }\n    JpegImage.prototype = {\n        get src() {\n            return this._src;\n        },\n        set src(value) {\n            this.load(value);\n        },\n        get width() {\n            return this._parser.width;\n        },\n        get height() {\n            return this._parser.height;\n        },\n        load: function load(path) {\n            this._src = path;\n            loadURLasArrayBuffer(path, function(buffer) {\n                this.parse(new Uint8Array(buffer));\n                if (this.onload) {\n                    this.onload();\n                }\n            }.bind(this));\n        },\n        parse: function(data) {\n            this._parser.parse(data);\n        },\n        getData: function(width, height) {\n            return this._parser.getData(width, height, false);\n        },\n        copyToImageData: function copyToImageData(imageData) {\n            if (this._parser.numComponents === 2 || this._parser.numComponents > 4) {\n                throw new Error("Unsupported amount of components");\n            }\n            var width = imageData.width, height = imageData.height;\n            var imageDataBytes = width * height * 4;\n            var imageDataArray = imageData.data;\n            var i, j;\n            if (this._parser.numComponents === 1) {\n                var values = this._parser.getData(width, height, false);\n                for (i = 0, j = 0; i < imageDataBytes; ) {\n                    var value = values[j++];\n                    imageDataArray[i++] = value;\n                    imageDataArray[i++] = value;\n                    imageDataArray[i++] = value;\n                    imageDataArray[i++] = 255;\n                }\n                return;\n            }\n            var rgb = this._parser.getData(width, height, true);\n            for (i = 0, j = 0; i < imageDataBytes; ) {\n                imageDataArray[i++] = rgb[j++];\n                imageDataArray[i++] = rgb[j++];\n                imageDataArray[i++] = rgb[j++];\n                imageDataArray[i++] = 255;\n            }\n        }\n    };\n    return JpegImage;\n}();\n\nif (typeof exports === "function") {\n    module.exports = {\n        JpegImage: JpegImage,\n        JpegDecoder: JpegDecoder,\n        JpxDecoder: JpxDecoder,\n        Jbig2Decoder: Jbig2Decoder\n    };\n}\n\nvar PDFJS;\n\n(function(PDFJS) {\n    "use strict";\n    var JpegImage = function jpegImage() {\n        var dctZigZag = new Uint8Array([ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 ]);\n        var dctCos1 = 4017;\n        var dctSin1 = 799;\n        var dctCos3 = 3406;\n        var dctSin3 = 2276;\n        var dctCos6 = 1567;\n        var dctSin6 = 3784;\n        var dctSqrt2 = 5793;\n        var dctSqrt1d2 = 2896;\n        function constructor() {}\n        function buildHuffmanTable(codeLengths, values) {\n            var k = 0, code = [], i, j, length = 16;\n            while (length > 0 && !codeLengths[length - 1]) {\n                length--;\n            }\n            code.push({\n                children: [],\n                index: 0\n            });\n            var p = code[0], q;\n            for (i = 0; i < length; i++) {\n                for (j = 0; j < codeLengths[i]; j++) {\n                    p = code.pop();\n                    p.children[p.index] = values[k];\n                    while (p.index > 0) {\n                        p = code.pop();\n                    }\n                    p.index++;\n                    code.push(p);\n                    while (code.length <= i) {\n                        code.push(q = {\n                            children: [],\n                            index: 0\n                        });\n                        p.children[p.index] = q.children;\n                        p = q;\n                    }\n                    k++;\n                }\n                if (i + 1 < length) {\n                    code.push(q = {\n                        children: [],\n                        index: 0\n                    });\n                    p.children[p.index] = q.children;\n                    p = q;\n                }\n            }\n            return code[0].children;\n        }\n        function getBlockBufferOffset(component, row, col) {\n            return 64 * ((component.blocksPerLine + 1) * row + col);\n        }\n        function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n            var precision = frame.precision;\n            var samplesPerLine = frame.samplesPerLine;\n            var scanLines = frame.scanLines;\n            var mcusPerLine = frame.mcusPerLine;\n            var progressive = frame.progressive;\n            var maxH = frame.maxH, maxV = frame.maxV;\n            var startOffset = offset, bitsData = 0, bitsCount = 0;\n            function readBit() {\n                if (bitsCount > 0) {\n                    bitsCount--;\n                    return bitsData >> bitsCount & 1;\n                }\n                bitsData = data[offset++];\n                if (bitsData === 255) {\n                    var nextByte = data[offset++];\n                    if (nextByte) {\n                        throw "unexpected marker: " + (bitsData << 8 | nextByte).toString(16);\n                    }\n                }\n                bitsCount = 7;\n                return bitsData >>> 7;\n            }\n            function decodeHuffman(tree) {\n                var node = tree;\n                while (true) {\n                    node = node[readBit()];\n                    if (typeof node === "number") {\n                        return node;\n                    }\n                    if (typeof node !== "object") {\n                        throw "invalid huffman sequence";\n                    }\n                }\n            }\n            function receive(length) {\n                var n = 0;\n                while (length > 0) {\n                    n = n << 1 | readBit();\n                    length--;\n                }\n                return n;\n            }\n            function receiveAndExtend(length) {\n                if (length === 1) {\n                    return readBit() === 1 ? 1 : -1;\n                }\n                var n = receive(length);\n                if (n >= 1 << length - 1) {\n                    return n;\n                }\n                return n + (-1 << length) + 1;\n            }\n            function decodeBaseline(component, offset) {\n                var t = decodeHuffman(component.huffmanTableDC);\n                var diff = t === 0 ? 0 : receiveAndExtend(t);\n                component.blockData[offset] = component.pred += diff;\n                var k = 1;\n                while (k < 64) {\n                    var rs = decodeHuffman(component.huffmanTableAC);\n                    var s = rs & 15, r = rs >> 4;\n                    if (s === 0) {\n                        if (r < 15) {\n                            break;\n                        }\n                        k += 16;\n                        continue;\n                    }\n                    k += r;\n                    var z = dctZigZag[k];\n                    component.blockData[offset + z] = receiveAndExtend(s);\n                    k++;\n                }\n            }\n            function decodeDCFirst(component, offset) {\n                var t = decodeHuffman(component.huffmanTableDC);\n                var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n                component.blockData[offset] = component.pred += diff;\n            }\n            function decodeDCSuccessive(component, offset) {\n                component.blockData[offset] |= readBit() << successive;\n            }\n            var eobrun = 0;\n            function decodeACFirst(component, offset) {\n                if (eobrun > 0) {\n                    eobrun--;\n                    return;\n                }\n                var k = spectralStart, e = spectralEnd;\n                while (k <= e) {\n                    var rs = decodeHuffman(component.huffmanTableAC);\n                    var s = rs & 15, r = rs >> 4;\n                    if (s === 0) {\n                        if (r < 15) {\n                            eobrun = receive(r) + (1 << r) - 1;\n                            break;\n                        }\n                        k += 16;\n                        continue;\n                    }\n                    k += r;\n                    var z = dctZigZag[k];\n                    component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n                    k++;\n                }\n            }\n            var successiveACState = 0, successiveACNextValue;\n            function decodeACSuccessive(component, offset) {\n                var k = spectralStart;\n                var e = spectralEnd;\n                var r = 0;\n                var s;\n                var rs;\n                while (k <= e) {\n                    var z = dctZigZag[k];\n                    switch (successiveACState) {\n                      case 0:\n                        rs = decodeHuffman(component.huffmanTableAC);\n                        s = rs & 15;\n                        r = rs >> 4;\n                        if (s === 0) {\n                            if (r < 15) {\n                                eobrun = receive(r) + (1 << r);\n                                successiveACState = 4;\n                            } else {\n                                r = 16;\n                                successiveACState = 1;\n                            }\n                        } else {\n                            if (s !== 1) {\n                                throw "invalid ACn encoding";\n                            }\n                            successiveACNextValue = receiveAndExtend(s);\n                            successiveACState = r ? 2 : 3;\n                        }\n                        continue;\n\n                      case 1:\n                      case 2:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += readBit() << successive;\n                        } else {\n                            r--;\n                            if (r === 0) {\n                                successiveACState = successiveACState === 2 ? 3 : 0;\n                            }\n                        }\n                        break;\n\n                      case 3:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += readBit() << successive;\n                        } else {\n                            component.blockData[offset + z] = successiveACNextValue << successive;\n                            successiveACState = 0;\n                        }\n                        break;\n\n                      case 4:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += readBit() << successive;\n                        }\n                        break;\n                    }\n                    k++;\n                }\n                if (successiveACState === 4) {\n                    eobrun--;\n                    if (eobrun === 0) {\n                        successiveACState = 0;\n                    }\n                }\n            }\n            function decodeMcu(component, decode, mcu, row, col) {\n                var mcuRow = mcu / mcusPerLine | 0;\n                var mcuCol = mcu % mcusPerLine;\n                var blockRow = mcuRow * component.v + row;\n                var blockCol = mcuCol * component.h + col;\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\n                decode(component, offset);\n            }\n            function decodeBlock(component, decode, mcu) {\n                var blockRow = mcu / component.blocksPerLine | 0;\n                var blockCol = mcu % component.blocksPerLine;\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\n                decode(component, offset);\n            }\n            var componentsLength = components.length;\n            var component, i, j, k, n;\n            var decodeFn;\n            if (progressive) {\n                if (spectralStart === 0) {\n                    decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n                } else {\n                    decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n                }\n            } else {\n                decodeFn = decodeBaseline;\n            }\n            var mcu = 0, marker;\n            var mcuExpected;\n            if (componentsLength === 1) {\n                mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n            } else {\n                mcuExpected = mcusPerLine * frame.mcusPerColumn;\n            }\n            if (!resetInterval) {\n                resetInterval = mcuExpected;\n            }\n            var h, v;\n            while (mcu < mcuExpected) {\n                for (i = 0; i < componentsLength; i++) {\n                    components[i].pred = 0;\n                }\n                eobrun = 0;\n                if (componentsLength === 1) {\n                    component = components[0];\n                    for (n = 0; n < resetInterval; n++) {\n                        decodeBlock(component, decodeFn, mcu);\n                        mcu++;\n                    }\n                } else {\n                    for (n = 0; n < resetInterval; n++) {\n                        for (i = 0; i < componentsLength; i++) {\n                            component = components[i];\n                            h = component.h;\n                            v = component.v;\n                            for (j = 0; j < v; j++) {\n                                for (k = 0; k < h; k++) {\n                                    decodeMcu(component, decodeFn, mcu, j, k);\n                                }\n                            }\n                        }\n                        mcu++;\n                    }\n                }\n                bitsCount = 0;\n                marker = data[offset] << 8 | data[offset + 1];\n                if (marker <= 65280) {\n                    throw "marker was not found";\n                }\n                if (marker >= 65488 && marker <= 65495) {\n                    offset += 2;\n                } else {\n                    break;\n                }\n            }\n            return offset - startOffset;\n        }\n        function quantizeAndInverse(component, blockBufferOffset, p) {\n            var qt = component.quantizationTable, blockData = component.blockData;\n            var v0, v1, v2, v3, v4, v5, v6, v7;\n            var p0, p1, p2, p3, p4, p5, p6, p7;\n            var t;\n            for (var row = 0; row < 64; row += 8) {\n                p0 = blockData[blockBufferOffset + row];\n                p1 = blockData[blockBufferOffset + row + 1];\n                p2 = blockData[blockBufferOffset + row + 2];\n                p3 = blockData[blockBufferOffset + row + 3];\n                p4 = blockData[blockBufferOffset + row + 4];\n                p5 = blockData[blockBufferOffset + row + 5];\n                p6 = blockData[blockBufferOffset + row + 6];\n                p7 = blockData[blockBufferOffset + row + 7];\n                p0 *= qt[row];\n                if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\n                    t = dctSqrt2 * p0 + 512 >> 10;\n                    p[row] = t;\n                    p[row + 1] = t;\n                    p[row + 2] = t;\n                    p[row + 3] = t;\n                    p[row + 4] = t;\n                    p[row + 5] = t;\n                    p[row + 6] = t;\n                    p[row + 7] = t;\n                    continue;\n                }\n                p1 *= qt[row + 1];\n                p2 *= qt[row + 2];\n                p3 *= qt[row + 3];\n                p4 *= qt[row + 4];\n                p5 *= qt[row + 5];\n                p6 *= qt[row + 6];\n                p7 *= qt[row + 7];\n                v0 = dctSqrt2 * p0 + 128 >> 8;\n                v1 = dctSqrt2 * p4 + 128 >> 8;\n                v2 = p2;\n                v3 = p6;\n                v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;\n                v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;\n                v5 = p3 << 4;\n                v6 = p5 << 4;\n                v0 = v0 + v1 + 1 >> 1;\n                v1 = v0 - v1;\n                t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n                v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n                v3 = t;\n                v4 = v4 + v6 + 1 >> 1;\n                v6 = v4 - v6;\n                v7 = v7 + v5 + 1 >> 1;\n                v5 = v7 - v5;\n                v0 = v0 + v3 + 1 >> 1;\n                v3 = v0 - v3;\n                v1 = v1 + v2 + 1 >> 1;\n                v2 = v1 - v2;\n                t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n                v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n                v7 = t;\n                t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n                v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n                v6 = t;\n                p[row] = v0 + v7;\n                p[row + 7] = v0 - v7;\n                p[row + 1] = v1 + v6;\n                p[row + 6] = v1 - v6;\n                p[row + 2] = v2 + v5;\n                p[row + 5] = v2 - v5;\n                p[row + 3] = v3 + v4;\n                p[row + 4] = v3 - v4;\n            }\n            for (var col = 0; col < 8; ++col) {\n                p0 = p[col];\n                p1 = p[col + 8];\n                p2 = p[col + 16];\n                p3 = p[col + 24];\n                p4 = p[col + 32];\n                p5 = p[col + 40];\n                p6 = p[col + 48];\n                p7 = p[col + 56];\n                if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\n                    t = dctSqrt2 * p0 + 8192 >> 14;\n                    t = t < -2040 ? 0 : t >= 2024 ? 255 : t + 2056 >> 4;\n                    blockData[blockBufferOffset + col] = t;\n                    blockData[blockBufferOffset + col + 8] = t;\n                    blockData[blockBufferOffset + col + 16] = t;\n                    blockData[blockBufferOffset + col + 24] = t;\n                    blockData[blockBufferOffset + col + 32] = t;\n                    blockData[blockBufferOffset + col + 40] = t;\n                    blockData[blockBufferOffset + col + 48] = t;\n                    blockData[blockBufferOffset + col + 56] = t;\n                    continue;\n                }\n                v0 = dctSqrt2 * p0 + 2048 >> 12;\n                v1 = dctSqrt2 * p4 + 2048 >> 12;\n                v2 = p2;\n                v3 = p6;\n                v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;\n                v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;\n                v5 = p3;\n                v6 = p5;\n                v0 = (v0 + v1 + 1 >> 1) + 4112;\n                v1 = v0 - v1;\n                t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n                v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n                v3 = t;\n                v4 = v4 + v6 + 1 >> 1;\n                v6 = v4 - v6;\n                v7 = v7 + v5 + 1 >> 1;\n                v5 = v7 - v5;\n                v0 = v0 + v3 + 1 >> 1;\n                v3 = v0 - v3;\n                v1 = v1 + v2 + 1 >> 1;\n                v2 = v1 - v2;\n                t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n                v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n                v7 = t;\n                t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n                v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n                v6 = t;\n                p0 = v0 + v7;\n                p7 = v0 - v7;\n                p1 = v1 + v6;\n                p6 = v1 - v6;\n                p2 = v2 + v5;\n                p5 = v2 - v5;\n                p3 = v3 + v4;\n                p4 = v3 - v4;\n                p0 = p0 < 16 ? 0 : p0 >= 4080 ? 255 : p0 >> 4;\n                p1 = p1 < 16 ? 0 : p1 >= 4080 ? 255 : p1 >> 4;\n                p2 = p2 < 16 ? 0 : p2 >= 4080 ? 255 : p2 >> 4;\n                p3 = p3 < 16 ? 0 : p3 >= 4080 ? 255 : p3 >> 4;\n                p4 = p4 < 16 ? 0 : p4 >= 4080 ? 255 : p4 >> 4;\n                p5 = p5 < 16 ? 0 : p5 >= 4080 ? 255 : p5 >> 4;\n                p6 = p6 < 16 ? 0 : p6 >= 4080 ? 255 : p6 >> 4;\n                p7 = p7 < 16 ? 0 : p7 >= 4080 ? 255 : p7 >> 4;\n                blockData[blockBufferOffset + col] = p0;\n                blockData[blockBufferOffset + col + 8] = p1;\n                blockData[blockBufferOffset + col + 16] = p2;\n                blockData[blockBufferOffset + col + 24] = p3;\n                blockData[blockBufferOffset + col + 32] = p4;\n                blockData[blockBufferOffset + col + 40] = p5;\n                blockData[blockBufferOffset + col + 48] = p6;\n                blockData[blockBufferOffset + col + 56] = p7;\n            }\n        }\n        function buildComponentData(frame, component) {\n            var blocksPerLine = component.blocksPerLine;\n            var blocksPerColumn = component.blocksPerColumn;\n            var computationBuffer = new Int16Array(64);\n            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                    var offset = getBlockBufferOffset(component, blockRow, blockCol);\n                    quantizeAndInverse(component, offset, computationBuffer);\n                }\n            }\n            return component.blockData;\n        }\n        function clamp0to255(a) {\n            return a <= 0 ? 0 : a >= 255 ? 255 : a;\n        }\n        constructor.prototype = {\n            parse: function parse(data) {\n                function readUint16() {\n                    var value = data[offset] << 8 | data[offset + 1];\n                    offset += 2;\n                    return value;\n                }\n                function readDataBlock() {\n                    var length = readUint16();\n                    var array = data.subarray(offset, offset + length - 2);\n                    offset += array.length;\n                    return array;\n                }\n                function prepareComponents(frame) {\n                    var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n                    var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n                    for (var i = 0; i < frame.components.length; i++) {\n                        component = frame.components[i];\n                        var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\n                        var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\n                        var blocksPerLineForMcu = mcusPerLine * component.h;\n                        var blocksPerColumnForMcu = mcusPerColumn * component.v;\n                        var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n                        component.blockData = new Int16Array(blocksBufferSize);\n                        component.blocksPerLine = blocksPerLine;\n                        component.blocksPerColumn = blocksPerColumn;\n                    }\n                    frame.mcusPerLine = mcusPerLine;\n                    frame.mcusPerColumn = mcusPerColumn;\n                }\n                var offset = 0, length = data.length;\n                var jfif = null;\n                var adobe = null;\n                var pixels = null;\n                var frame, resetInterval;\n                var quantizationTables = [];\n                var huffmanTablesAC = [], huffmanTablesDC = [];\n                var fileMarker = readUint16();\n                if (fileMarker !== 65496) {\n                    throw "SOI not found";\n                }\n                fileMarker = readUint16();\n                while (fileMarker !== 65497) {\n                    var i, j, l;\n                    switch (fileMarker) {\n                      case 65504:\n                      case 65505:\n                      case 65506:\n                      case 65507:\n                      case 65508:\n                      case 65509:\n                      case 65510:\n                      case 65511:\n                      case 65512:\n                      case 65513:\n                      case 65514:\n                      case 65515:\n                      case 65516:\n                      case 65517:\n                      case 65518:\n                      case 65519:\n                      case 65534:\n                        var appData = readDataBlock();\n                        if (fileMarker === 65504) {\n                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {\n                                jfif = {\n                                    version: {\n                                        major: appData[5],\n                                        minor: appData[6]\n                                    },\n                                    densityUnits: appData[7],\n                                    xDensity: appData[8] << 8 | appData[9],\n                                    yDensity: appData[10] << 8 | appData[11],\n                                    thumbWidth: appData[12],\n                                    thumbHeight: appData[13],\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                                };\n                            }\n                        }\n                        if (fileMarker === 65518) {\n                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {\n                                adobe = {\n                                    version: appData[6],\n                                    flags0: appData[7] << 8 | appData[8],\n                                    flags1: appData[9] << 8 | appData[10],\n                                    transformCode: appData[11]\n                                };\n                            }\n                        }\n                        break;\n\n                      case 65499:\n                        var quantizationTablesLength = readUint16();\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                        var z;\n                        while (offset < quantizationTablesEnd) {\n                            var quantizationTableSpec = data[offset++];\n                            var tableData = new Uint16Array(64);\n                            if (quantizationTableSpec >> 4 === 0) {\n                                for (j = 0; j < 64; j++) {\n                                    z = dctZigZag[j];\n                                    tableData[z] = data[offset++];\n                                }\n                            } else if (quantizationTableSpec >> 4 === 1) {\n                                for (j = 0; j < 64; j++) {\n                                    z = dctZigZag[j];\n                                    tableData[z] = readUint16();\n                                }\n                            } else {\n                                throw "DQT: invalid table spec";\n                            }\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\n                        }\n                        break;\n\n                      case 65472:\n                      case 65473:\n                      case 65474:\n                        if (frame) {\n                            throw "Only single frame JPEGs supported";\n                        }\n                        readUint16();\n                        frame = {};\n                        frame.extended = fileMarker === 65473;\n                        frame.progressive = fileMarker === 65474;\n                        frame.precision = data[offset++];\n                        frame.scanLines = readUint16();\n                        frame.samplesPerLine = readUint16();\n                        frame.components = [];\n                        frame.componentIds = {};\n                        var componentsCount = data[offset++], componentId;\n                        var maxH = 0, maxV = 0;\n                        for (i = 0; i < componentsCount; i++) {\n                            componentId = data[offset];\n                            var h = data[offset + 1] >> 4;\n                            var v = data[offset + 1] & 15;\n                            if (maxH < h) {\n                                maxH = h;\n                            }\n                            if (maxV < v) {\n                                maxV = v;\n                            }\n                            var qId = data[offset + 2];\n                            l = frame.components.push({\n                                h: h,\n                                v: v,\n                                quantizationTable: quantizationTables[qId]\n                            });\n                            frame.componentIds[componentId] = l - 1;\n                            offset += 3;\n                        }\n                        frame.maxH = maxH;\n                        frame.maxV = maxV;\n                        prepareComponents(frame);\n                        break;\n\n                      case 65476:\n                        var huffmanLength = readUint16();\n                        for (i = 2; i < huffmanLength; ) {\n                            var huffmanTableSpec = data[offset++];\n                            var codeLengths = new Uint8Array(16);\n                            var codeLengthSum = 0;\n                            for (j = 0; j < 16; j++, offset++) {\n                                codeLengthSum += codeLengths[j] = data[offset];\n                            }\n                            var huffmanValues = new Uint8Array(codeLengthSum);\n                            for (j = 0; j < codeLengthSum; j++, offset++) {\n                                huffmanValues[j] = data[offset];\n                            }\n                            i += 17 + codeLengthSum;\n                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                        break;\n\n                      case 65501:\n                        readUint16();\n                        resetInterval = readUint16();\n                        break;\n\n                      case 65498:\n                        var scanLength = readUint16();\n                        var selectorsCount = data[offset++];\n                        var components = [], component;\n                        for (i = 0; i < selectorsCount; i++) {\n                            var componentIndex = frame.componentIds[data[offset++]];\n                            component = frame.components[componentIndex];\n                            var tableSpec = data[offset++];\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                            components.push(component);\n                        }\n                        var spectralStart = data[offset++];\n                        var spectralEnd = data[offset++];\n                        var successiveApproximation = data[offset++];\n                        var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n                        offset += processed;\n                        break;\n\n                      case 65535:\n                        if (data[offset] !== 255) {\n                            offset--;\n                        }\n                        break;\n\n                      default:\n                        if (data[offset - 3] === 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {\n                            offset -= 3;\n                            break;\n                        }\n                        throw "unknown JPEG marker " + fileMarker.toString(16);\n                    }\n                    fileMarker = readUint16();\n                }\n                this.width = frame.samplesPerLine;\n                this.height = frame.scanLines;\n                this.jfif = jfif;\n                this.adobe = adobe;\n                this.components = [];\n                for (i = 0; i < frame.components.length; i++) {\n                    component = frame.components[i];\n                    this.components.push({\n                        output: buildComponentData(frame, component),\n                        scaleX: component.h / frame.maxH,\n                        scaleY: component.v / frame.maxV,\n                        blocksPerLine: component.blocksPerLine,\n                        blocksPerColumn: component.blocksPerColumn\n                    });\n                }\n                this.numComponents = this.components.length;\n            },\n            _getLinearizedBlockData: function getLinearizedBlockData(width, height) {\n                var scaleX = this.width / width, scaleY = this.height / height;\n                var component, componentScaleX, componentScaleY, blocksPerScanline;\n                var x, y, i, j, k;\n                var index;\n                var offset = 0;\n                var output;\n                var numComponents = this.components.length;\n                var dataLength = width * height * numComponents;\n                var data = new Uint8Array(dataLength);\n                var xScaleBlockOffset = new Uint32Array(width);\n                var mask3LSB = 4294967288;\n                for (i = 0; i < numComponents; i++) {\n                    component = this.components[i];\n                    componentScaleX = component.scaleX * scaleX;\n                    componentScaleY = component.scaleY * scaleY;\n                    offset = i;\n                    output = component.output;\n                    blocksPerScanline = component.blocksPerLine + 1 << 3;\n                    for (x = 0; x < width; x++) {\n                        j = 0 | x * componentScaleX;\n                        xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;\n                    }\n                    for (y = 0; y < height; y++) {\n                        j = 0 | y * componentScaleY;\n                        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;\n                        for (x = 0; x < width; x++) {\n                            data[offset] = output[index + xScaleBlockOffset[x]];\n                            offset += numComponents;\n                        }\n                    }\n                }\n                var transform = this.decodeTransform;\n                if (transform) {\n                    for (i = 0; i < dataLength; ) {\n                        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {\n                            data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];\n                        }\n                    }\n                }\n                return data;\n            },\n            _isColorConversionNeeded: function isColorConversionNeeded() {\n                if (this.adobe && this.adobe.transformCode) {\n                    return true;\n                } else if (this.numComponents === 3) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            _convertYccToRgb: function convertYccToRgb(data) {\n                var Y, Cb, Cr;\n                for (var i = 0, length = data.length; i < length; i += 3) {\n                    Y = data[i];\n                    Cb = data[i + 1];\n                    Cr = data[i + 2];\n                    data[i] = clamp0to255(Y - 179.456 + 1.402 * Cr);\n                    data[i + 1] = clamp0to255(Y + 135.459 - .344 * Cb - .714 * Cr);\n                    data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);\n                }\n                return data;\n            },\n            _convertYcckToRgb: function convertYcckToRgb(data) {\n                var Y, Cb, Cr, k;\n                var offset = 0;\n                for (var i = 0, length = data.length; i < length; i += 4) {\n                    Y = data[i];\n                    Cb = data[i + 1];\n                    Cr = data[i + 2];\n                    k = data[i + 3];\n                    var r = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + .000437130475926232 * Cr - 54080610064599e-18 * Y + .00048449797120281 * k - .154362151871126) + Cr * (-.000957964378445773 * Cr + .000817076911346625 * Y - .00477271405408747 * k + 1.53380253221734) + Y * (.000961250184130688 * Y - .00266257332283933 * k + .48357088451265) + k * (-.000336197177618394 * k + .484791561490776);\n                    var g = 107.268039397724 + Cb * (219927104525741e-19 * Cb - .000640992018297945 * Cr + .000659397001245577 * Y + .000426105652938837 * k - .176491792462875) + Cr * (-.000778269941513683 * Cr + .00130872261408275 * Y + .000770482631801132 * k - .151051492775562) + Y * (.00126935368114843 * Y - .00265090189010898 * k + .25802910206845) + k * (-.000318913117588328 * k - .213742400323665);\n                    var b = -20.810012546947 + Cb * (-.000570115196973677 * Cb - 263409051004589e-19 * Cr + .0020741088115012 * Y - .00288260236853442 * k + .814272968359295) + Cr * (-153496057440975e-19 * Cr - .000132689043961446 * Y + .000560833691242812 * k - .195152027534049) + Y * (.00174418132927582 * Y - .00255243321439347 * k + .116935020465145) + k * (-.000343531996510555 * k + .24165260232407);\n                    data[offset++] = clamp0to255(r);\n                    data[offset++] = clamp0to255(g);\n                    data[offset++] = clamp0to255(b);\n                }\n                return data;\n            },\n            _convertYcckToCmyk: function convertYcckToCmyk(data) {\n                var Y, Cb, Cr;\n                for (var i = 0, length = data.length; i < length; i += 4) {\n                    Y = data[i];\n                    Cb = data[i + 1];\n                    Cr = data[i + 2];\n                    data[i] = clamp0to255(434.456 - Y - 1.402 * Cr);\n                    data[i + 1] = clamp0to255(119.541 - Y + .344 * Cb + .714 * Cr);\n                    data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);\n                }\n                return data;\n            },\n            _convertCmykToRgb: function convertCmykToRgb(data) {\n                var c, m, y, k;\n                var offset = 0;\n                var min = -255 * 255 * 255;\n                var scale = 1 / 255 / 255;\n                for (var i = 0, length = data.length; i < length; i += 4) {\n                    c = data[i];\n                    m = data[i + 1];\n                    y = data[i + 2];\n                    k = data[i + 3];\n                    var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k - 72734.4411664936) + m * (1.7149763477362134 * m - 5.6096736904047315 * y - 17.873870861415444 * k - 1401.7366389350734) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 4465.541406466231) - k * (21.86122147463605 * k + 48317.86113160301);\n                    var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k - 20220.756542821975) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 48691.05921601825) + y * (4.444339102852739 * y + 9.8632861493405 * k - 6341.191035517494) - k * (20.737325471181034 * k + 47890.15695978492);\n                    var b = c * (.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - .23883238689178934 * k - 3616.812083916688) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 28620.90484698408) + y * (.03296041114873217 * y + 115.60384449646641 * k - 49363.43385999684) - k * (22.33816807309886 * k + 45932.16563550634);\n                    data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;\n                    data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;\n                    data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;\n                }\n                return data;\n            },\n            getData: function getData(width, height, forceRGBoutput) {\n                if (this.numComponents > 4) {\n                    throw "Unsupported color mode";\n                }\n                var data = this._getLinearizedBlockData(width, height);\n                if (this.numComponents === 3) {\n                    return this._convertYccToRgb(data);\n                } else if (this.numComponents === 4) {\n                    if (this._isColorConversionNeeded()) {\n                        if (forceRGBoutput) {\n                            return this._convertYcckToRgb(data);\n                        } else {\n                            return this._convertYcckToCmyk(data);\n                        }\n                    } else if (forceRGBoutput) {\n                        return this._convertCmykToRgb(data);\n                    }\n                }\n                return data;\n            }\n        };\n        return constructor;\n    }();\n    "use strict";\n    var ArithmeticDecoder = function ArithmeticDecoderClosure() {\n        var QeTable = [ {\n            qe: 22017,\n            nmps: 1,\n            nlps: 1,\n            switchFlag: 1\n        }, {\n            qe: 13313,\n            nmps: 2,\n            nlps: 6,\n            switchFlag: 0\n        }, {\n            qe: 6145,\n            nmps: 3,\n            nlps: 9,\n            switchFlag: 0\n        }, {\n            qe: 2753,\n            nmps: 4,\n            nlps: 12,\n            switchFlag: 0\n        }, {\n            qe: 1313,\n            nmps: 5,\n            nlps: 29,\n            switchFlag: 0\n        }, {\n            qe: 545,\n            nmps: 38,\n            nlps: 33,\n            switchFlag: 0\n        }, {\n            qe: 22017,\n            nmps: 7,\n            nlps: 6,\n            switchFlag: 1\n        }, {\n            qe: 21505,\n            nmps: 8,\n            nlps: 14,\n            switchFlag: 0\n        }, {\n            qe: 18433,\n            nmps: 9,\n            nlps: 14,\n            switchFlag: 0\n        }, {\n            qe: 14337,\n            nmps: 10,\n            nlps: 14,\n            switchFlag: 0\n        }, {\n            qe: 12289,\n            nmps: 11,\n            nlps: 17,\n            switchFlag: 0\n        }, {\n            qe: 9217,\n            nmps: 12,\n            nlps: 18,\n            switchFlag: 0\n        }, {\n            qe: 7169,\n            nmps: 13,\n            nlps: 20,\n            switchFlag: 0\n        }, {\n            qe: 5633,\n            nmps: 29,\n            nlps: 21,\n            switchFlag: 0\n        }, {\n            qe: 22017,\n            nmps: 15,\n            nlps: 14,\n            switchFlag: 1\n        }, {\n            qe: 21505,\n            nmps: 16,\n            nlps: 14,\n            switchFlag: 0\n        }, {\n            qe: 20737,\n            nmps: 17,\n            nlps: 15,\n            switchFlag: 0\n        }, {\n            qe: 18433,\n            nmps: 18,\n            nlps: 16,\n            switchFlag: 0\n        }, {\n            qe: 14337,\n            nmps: 19,\n            nlps: 17,\n            switchFlag: 0\n        }, {\n            qe: 13313,\n            nmps: 20,\n            nlps: 18,\n            switchFlag: 0\n        }, {\n            qe: 12289,\n            nmps: 21,\n            nlps: 19,\n            switchFlag: 0\n        }, {\n            qe: 10241,\n            nmps: 22,\n            nlps: 19,\n            switchFlag: 0\n        }, {\n            qe: 9217,\n            nmps: 23,\n            nlps: 20,\n            switchFlag: 0\n        }, {\n            qe: 8705,\n            nmps: 24,\n            nlps: 21,\n            switchFlag: 0\n        }, {\n            qe: 7169,\n            nmps: 25,\n            nlps: 22,\n            switchFlag: 0\n        }, {\n            qe: 6145,\n            nmps: 26,\n            nlps: 23,\n            switchFlag: 0\n        }, {\n            qe: 5633,\n            nmps: 27,\n            nlps: 24,\n            switchFlag: 0\n        }, {\n            qe: 5121,\n            nmps: 28,\n            nlps: 25,\n            switchFlag: 0\n        }, {\n            qe: 4609,\n            nmps: 29,\n            nlps: 26,\n            switchFlag: 0\n        }, {\n            qe: 4353,\n            nmps: 30,\n            nlps: 27,\n            switchFlag: 0\n        }, {\n            qe: 2753,\n            nmps: 31,\n            nlps: 28,\n            switchFlag: 0\n        }, {\n            qe: 2497,\n            nmps: 32,\n            nlps: 29,\n            switchFlag: 0\n        }, {\n            qe: 2209,\n            nmps: 33,\n            nlps: 30,\n            switchFlag: 0\n        }, {\n            qe: 1313,\n            nmps: 34,\n            nlps: 31,\n            switchFlag: 0\n        }, {\n            qe: 1089,\n            nmps: 35,\n            nlps: 32,\n            switchFlag: 0\n        }, {\n            qe: 673,\n            nmps: 36,\n            nlps: 33,\n            switchFlag: 0\n        }, {\n            qe: 545,\n            nmps: 37,\n            nlps: 34,\n            switchFlag: 0\n        }, {\n            qe: 321,\n            nmps: 38,\n            nlps: 35,\n            switchFlag: 0\n        }, {\n            qe: 273,\n            nmps: 39,\n            nlps: 36,\n            switchFlag: 0\n        }, {\n            qe: 133,\n            nmps: 40,\n            nlps: 37,\n            switchFlag: 0\n        }, {\n            qe: 73,\n            nmps: 41,\n            nlps: 38,\n            switchFlag: 0\n        }, {\n            qe: 37,\n            nmps: 42,\n            nlps: 39,\n            switchFlag: 0\n        }, {\n            qe: 21,\n            nmps: 43,\n            nlps: 40,\n            switchFlag: 0\n        }, {\n            qe: 9,\n            nmps: 44,\n            nlps: 41,\n            switchFlag: 0\n        }, {\n            qe: 5,\n            nmps: 45,\n            nlps: 42,\n            switchFlag: 0\n        }, {\n            qe: 1,\n            nmps: 45,\n            nlps: 43,\n            switchFlag: 0\n        }, {\n            qe: 22017,\n            nmps: 46,\n            nlps: 46,\n            switchFlag: 0\n        } ];\n        function ArithmeticDecoder(data, start, end) {\n            this.data = data;\n            this.bp = start;\n            this.dataEnd = end;\n            this.chigh = data[start];\n            this.clow = 0;\n            this.byteIn();\n            this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;\n            this.clow = this.clow << 7 & 65535;\n            this.ct -= 7;\n            this.a = 32768;\n        }\n        ArithmeticDecoder.prototype = {\n            byteIn: function ArithmeticDecoder_byteIn() {\n                var data = this.data;\n                var bp = this.bp;\n                if (data[bp] === 255) {\n                    var b1 = data[bp + 1];\n                    if (b1 > 143) {\n                        this.clow += 65280;\n                        this.ct = 8;\n                    } else {\n                        bp++;\n                        this.clow += data[bp] << 9;\n                        this.ct = 7;\n                        this.bp = bp;\n                    }\n                } else {\n                    bp++;\n                    this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;\n                    this.ct = 8;\n                    this.bp = bp;\n                }\n                if (this.clow > 65535) {\n                    this.chigh += this.clow >> 16;\n                    this.clow &= 65535;\n                }\n            },\n            readBit: function ArithmeticDecoder_readBit(contexts, pos) {\n                var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;\n                var qeTableIcx = QeTable[cx_index];\n                var qeIcx = qeTableIcx.qe;\n                var d;\n                var a = this.a - qeIcx;\n                if (this.chigh < qeIcx) {\n                    if (a < qeIcx) {\n                        a = qeIcx;\n                        d = cx_mps;\n                        cx_index = qeTableIcx.nmps;\n                    } else {\n                        a = qeIcx;\n                        d = 1 ^ cx_mps;\n                        if (qeTableIcx.switchFlag === 1) {\n                            cx_mps = d;\n                        }\n                        cx_index = qeTableIcx.nlps;\n                    }\n                } else {\n                    this.chigh -= qeIcx;\n                    if ((a & 32768) !== 0) {\n                        this.a = a;\n                        return cx_mps;\n                    }\n                    if (a < qeIcx) {\n                        d = 1 ^ cx_mps;\n                        if (qeTableIcx.switchFlag === 1) {\n                            cx_mps = d;\n                        }\n                        cx_index = qeTableIcx.nlps;\n                    } else {\n                        d = cx_mps;\n                        cx_index = qeTableIcx.nmps;\n                    }\n                }\n                do {\n                    if (this.ct === 0) {\n                        this.byteIn();\n                    }\n                    a <<= 1;\n                    this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;\n                    this.clow = this.clow << 1 & 65535;\n                    this.ct--;\n                } while ((a & 32768) === 0);\n                this.a = a;\n                contexts[pos] = cx_index << 1 | cx_mps;\n                return d;\n            }\n        };\n        return ArithmeticDecoder;\n    }();\n    "use strict";\n    var JpxImage = function JpxImageClosure() {\n        var SubbandsGainLog2 = {\n            LL: 0,\n            LH: 1,\n            HL: 1,\n            HH: 2\n        };\n        function JpxImage() {\n            this.failOnCorruptedImage = false;\n        }\n        JpxImage.prototype = {\n            parse: function JpxImage_parse(data) {\n                var head = readUint16(data, 0);\n                if (head === 65359) {\n                    this.parseCodestream(data, 0, data.length);\n                    return;\n                }\n                var position = 0, length = data.length;\n                while (position < length) {\n                    var headerSize = 8;\n                    var lbox = readUint32(data, position);\n                    var tbox = readUint32(data, position + 4);\n                    position += headerSize;\n                    if (lbox === 1) {\n                        lbox = readUint32(data, position) * 4294967296 + readUint32(data, position + 4);\n                        position += 8;\n                        headerSize += 8;\n                    }\n                    if (lbox === 0) {\n                        lbox = length - position + headerSize;\n                    }\n                    if (lbox < headerSize) {\n                        throw new Error("JPX Error: Invalid box field size");\n                    }\n                    var dataLength = lbox - headerSize;\n                    var jumpDataLength = true;\n                    switch (tbox) {\n                      case 1785737832:\n                        jumpDataLength = false;\n                        break;\n\n                      case 1668246642:\n                        var method = data[position];\n                        var precedence = data[position + 1];\n                        var approximation = data[position + 2];\n                        if (method === 1) {\n                            var colorspace = readUint32(data, position + 3);\n                            switch (colorspace) {\n                              case 16:\n                              case 17:\n                              case 18:\n                                break;\n\n                              default:\n                                warn("Unknown colorspace " + colorspace);\n                                break;\n                            }\n                        } else if (method === 2) {\n                            info("ICC profile not supported");\n                        }\n                        break;\n\n                      case 1785737827:\n                        this.parseCodestream(data, position, position + dataLength);\n                        break;\n\n                      case 1783636e3:\n                        if (218793738 !== readUint32(data, position)) {\n                            warn("Invalid JP2 signature");\n                        }\n                        break;\n\n                      case 1783634458:\n                      case 1718909296:\n                      case 1920099697:\n                      case 1919251232:\n                      case 1768449138:\n                        break;\n\n                      default:\n                        var headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);\n                        warn("Unsupported header type " + tbox + " (" + headerType + ")");\n                        break;\n                    }\n                    if (jumpDataLength) {\n                        position += dataLength;\n                    }\n                }\n            },\n            parseImageProperties: function JpxImage_parseImageProperties(stream) {\n                var newByte = stream.getByte();\n                while (newByte >= 0) {\n                    var oldByte = newByte;\n                    newByte = stream.getByte();\n                    var code = oldByte << 8 | newByte;\n                    if (code === 65361) {\n                        stream.skip(4);\n                        var Xsiz = stream.getInt32() >>> 0;\n                        var Ysiz = stream.getInt32() >>> 0;\n                        var XOsiz = stream.getInt32() >>> 0;\n                        var YOsiz = stream.getInt32() >>> 0;\n                        stream.skip(16);\n                        var Csiz = stream.getUint16();\n                        this.width = Xsiz - XOsiz;\n                        this.height = Ysiz - YOsiz;\n                        this.componentsCount = Csiz;\n                        this.bitsPerComponent = 8;\n                        return;\n                    }\n                }\n                throw new Error("JPX Error: No size marker found in JPX stream");\n            },\n            parseCodestream: function JpxImage_parseCodestream(data, start, end) {\n                var context = {};\n                try {\n                    var doNotRecover = false;\n                    var position = start;\n                    while (position + 1 < end) {\n                        var code = readUint16(data, position);\n                        position += 2;\n                        var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;\n                        switch (code) {\n                          case 65359:\n                            context.mainHeader = true;\n                            break;\n\n                          case 65497:\n                            break;\n\n                          case 65361:\n                            length = readUint16(data, position);\n                            var siz = {};\n                            siz.Xsiz = readUint32(data, position + 4);\n                            siz.Ysiz = readUint32(data, position + 8);\n                            siz.XOsiz = readUint32(data, position + 12);\n                            siz.YOsiz = readUint32(data, position + 16);\n                            siz.XTsiz = readUint32(data, position + 20);\n                            siz.YTsiz = readUint32(data, position + 24);\n                            siz.XTOsiz = readUint32(data, position + 28);\n                            siz.YTOsiz = readUint32(data, position + 32);\n                            var componentsCount = readUint16(data, position + 36);\n                            siz.Csiz = componentsCount;\n                            var components = [];\n                            j = position + 38;\n                            for (var i = 0; i < componentsCount; i++) {\n                                var component = {\n                                    precision: (data[j] & 127) + 1,\n                                    isSigned: !!(data[j] & 128),\n                                    XRsiz: data[j + 1],\n                                    YRsiz: data[j + 1]\n                                };\n                                calculateComponentDimensions(component, siz);\n                                components.push(component);\n                            }\n                            context.SIZ = siz;\n                            context.components = components;\n                            calculateTileGrids(context, components);\n                            context.QCC = [];\n                            context.COC = [];\n                            break;\n\n                          case 65372:\n                            length = readUint16(data, position);\n                            var qcd = {};\n                            j = position + 2;\n                            sqcd = data[j++];\n                            switch (sqcd & 31) {\n                              case 0:\n                                spqcdSize = 8;\n                                scalarExpounded = true;\n                                break;\n\n                              case 1:\n                                spqcdSize = 16;\n                                scalarExpounded = false;\n                                break;\n\n                              case 2:\n                                spqcdSize = 16;\n                                scalarExpounded = true;\n                                break;\n\n                              default:\n                                throw new Error("JPX Error: Invalid SQcd value " + sqcd);\n                            }\n                            qcd.noQuantization = spqcdSize === 8;\n                            qcd.scalarExpounded = scalarExpounded;\n                            qcd.guardBits = sqcd >> 5;\n                            spqcds = [];\n                            while (j < length + position) {\n                                var spqcd = {};\n                                if (spqcdSize === 8) {\n                                    spqcd.epsilon = data[j++] >> 3;\n                                    spqcd.mu = 0;\n                                } else {\n                                    spqcd.epsilon = data[j] >> 3;\n                                    spqcd.mu = (data[j] & 7) << 8 | data[j + 1];\n                                    j += 2;\n                                }\n                                spqcds.push(spqcd);\n                            }\n                            qcd.SPqcds = spqcds;\n                            if (context.mainHeader) {\n                                context.QCD = qcd;\n                            } else {\n                                context.currentTile.QCD = qcd;\n                                context.currentTile.QCC = [];\n                            }\n                            break;\n\n                          case 65373:\n                            length = readUint16(data, position);\n                            var qcc = {};\n                            j = position + 2;\n                            var cqcc;\n                            if (context.SIZ.Csiz < 257) {\n                                cqcc = data[j++];\n                            } else {\n                                cqcc = readUint16(data, j);\n                                j += 2;\n                            }\n                            sqcd = data[j++];\n                            switch (sqcd & 31) {\n                              case 0:\n                                spqcdSize = 8;\n                                scalarExpounded = true;\n                                break;\n\n                              case 1:\n                                spqcdSize = 16;\n                                scalarExpounded = false;\n                                break;\n\n                              case 2:\n                                spqcdSize = 16;\n                                scalarExpounded = true;\n                                break;\n\n                              default:\n                                throw new Error("JPX Error: Invalid SQcd value " + sqcd);\n                            }\n                            qcc.noQuantization = spqcdSize === 8;\n                            qcc.scalarExpounded = scalarExpounded;\n                            qcc.guardBits = sqcd >> 5;\n                            spqcds = [];\n                            while (j < length + position) {\n                                spqcd = {};\n                                if (spqcdSize === 8) {\n                                    spqcd.epsilon = data[j++] >> 3;\n                                    spqcd.mu = 0;\n                                } else {\n                                    spqcd.epsilon = data[j] >> 3;\n                                    spqcd.mu = (data[j] & 7) << 8 | data[j + 1];\n                                    j += 2;\n                                }\n                                spqcds.push(spqcd);\n                            }\n                            qcc.SPqcds = spqcds;\n                            if (context.mainHeader) {\n                                context.QCC[cqcc] = qcc;\n                            } else {\n                                context.currentTile.QCC[cqcc] = qcc;\n                            }\n                            break;\n\n                          case 65362:\n                            length = readUint16(data, position);\n                            var cod = {};\n                            j = position + 2;\n                            var scod = data[j++];\n                            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);\n                            cod.sopMarkerUsed = !!(scod & 2);\n                            cod.ephMarkerUsed = !!(scod & 4);\n                            cod.progressionOrder = data[j++];\n                            cod.layersCount = readUint16(data, j);\n                            j += 2;\n                            cod.multipleComponentTransform = data[j++];\n                            cod.decompositionLevelsCount = data[j++];\n                            cod.xcb = (data[j++] & 15) + 2;\n                            cod.ycb = (data[j++] & 15) + 2;\n                            var blockStyle = data[j++];\n                            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);\n                            cod.resetContextProbabilities = !!(blockStyle & 2);\n                            cod.terminationOnEachCodingPass = !!(blockStyle & 4);\n                            cod.verticalyStripe = !!(blockStyle & 8);\n                            cod.predictableTermination = !!(blockStyle & 16);\n                            cod.segmentationSymbolUsed = !!(blockStyle & 32);\n                            cod.reversibleTransformation = data[j++];\n                            if (cod.entropyCoderWithCustomPrecincts) {\n                                var precinctsSizes = [];\n                                while (j < length + position) {\n                                    var precinctsSize = data[j++];\n                                    precinctsSizes.push({\n                                        PPx: precinctsSize & 15,\n                                        PPy: precinctsSize >> 4\n                                    });\n                                }\n                                cod.precinctsSizes = precinctsSizes;\n                            }\n                            var unsupported = [];\n                            if (cod.selectiveArithmeticCodingBypass) {\n                                unsupported.push("selectiveArithmeticCodingBypass");\n                            }\n                            if (cod.resetContextProbabilities) {\n                                unsupported.push("resetContextProbabilities");\n                            }\n                            if (cod.terminationOnEachCodingPass) {\n                                unsupported.push("terminationOnEachCodingPass");\n                            }\n                            if (cod.verticalyStripe) {\n                                unsupported.push("verticalyStripe");\n                            }\n                            if (cod.predictableTermination) {\n                                unsupported.push("predictableTermination");\n                            }\n                            if (unsupported.length > 0) {\n                                doNotRecover = true;\n                                throw new Error("JPX Error: Unsupported COD options (" + unsupported.join(", ") + ")");\n                            }\n                            if (context.mainHeader) {\n                                context.COD = cod;\n                            } else {\n                                context.currentTile.COD = cod;\n                                context.currentTile.COC = [];\n                            }\n                            break;\n\n                          case 65424:\n                            length = readUint16(data, position);\n                            tile = {};\n                            tile.index = readUint16(data, position + 2);\n                            tile.length = readUint32(data, position + 4);\n                            tile.dataEnd = tile.length + position - 2;\n                            tile.partIndex = data[position + 8];\n                            tile.partsCount = data[position + 9];\n                            context.mainHeader = false;\n                            if (tile.partIndex === 0) {\n                                tile.COD = context.COD;\n                                tile.COC = context.COC.slice(0);\n                                tile.QCD = context.QCD;\n                                tile.QCC = context.QCC.slice(0);\n                            }\n                            context.currentTile = tile;\n                            break;\n\n                          case 65427:\n                            tile = context.currentTile;\n                            if (tile.partIndex === 0) {\n                                initializeTile(context, tile.index);\n                                buildPackets(context);\n                            }\n                            length = tile.dataEnd - position;\n                            parseTilePackets(context, data, position, length);\n                            break;\n\n                          case 65365:\n                          case 65367:\n                          case 65368:\n                          case 65380:\n                            length = readUint16(data, position);\n                            break;\n\n                          case 65363:\n                            throw new Error("JPX Error: Codestream code 0xFF53 (COC) is " + "not implemented");\n\n                          default:\n                            throw new Error("JPX Error: Unknown codestream code: " + code.toString(16));\n                        }\n                        position += length;\n                    }\n                } catch (e) {\n                    if (doNotRecover || this.failOnCorruptedImage) {\n                        throw e;\n                    } else {\n                        warn("Trying to recover from " + e.message);\n                    }\n                }\n                this.tiles = transformComponents(context);\n                this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;\n                this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;\n                this.componentsCount = context.SIZ.Csiz;\n            }\n        };\n        function calculateComponentDimensions(component, siz) {\n            component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);\n            component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);\n            component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);\n            component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);\n            component.width = component.x1 - component.x0;\n            component.height = component.y1 - component.y0;\n        }\n        function calculateTileGrids(context, components) {\n            var siz = context.SIZ;\n            var tile, tiles = [];\n            var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);\n            var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);\n            for (var q = 0; q < numYtiles; q++) {\n                for (var p = 0; p < numXtiles; p++) {\n                    tile = {};\n                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);\n                    tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);\n                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);\n                    tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);\n                    tile.width = tile.tx1 - tile.tx0;\n                    tile.height = tile.ty1 - tile.ty0;\n                    tile.components = [];\n                    tiles.push(tile);\n                }\n            }\n            context.tiles = tiles;\n            var componentsCount = siz.Csiz;\n            for (var i = 0, ii = componentsCount; i < ii; i++) {\n                var component = components[i];\n                for (var j = 0, jj = tiles.length; j < jj; j++) {\n                    var tileComponent = {};\n                    tile = tiles[j];\n                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);\n                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);\n                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);\n                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);\n                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;\n                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;\n                    tile.components[i] = tileComponent;\n                }\n            }\n        }\n        function getBlocksDimensions(context, component, r) {\n            var codOrCoc = component.codingStyleParameters;\n            var result = {};\n            if (!codOrCoc.entropyCoderWithCustomPrecincts) {\n                result.PPx = 15;\n                result.PPy = 15;\n            } else {\n                result.PPx = codOrCoc.precinctsSizes[r].PPx;\n                result.PPy = codOrCoc.precinctsSizes[r].PPy;\n            }\n            result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);\n            result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);\n            return result;\n        }\n        function buildPrecincts(context, resolution, dimensions) {\n            var precinctWidth = 1 << dimensions.PPx;\n            var precinctHeight = 1 << dimensions.PPy;\n            var isZeroRes = resolution.resLevel === 0;\n            var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);\n            var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);\n            var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;\n            var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;\n            var numprecincts = numprecinctswide * numprecinctshigh;\n            resolution.precinctParameters = {\n                precinctWidth: precinctWidth,\n                precinctHeight: precinctHeight,\n                numprecinctswide: numprecinctswide,\n                numprecinctshigh: numprecinctshigh,\n                numprecincts: numprecincts,\n                precinctWidthInSubband: precinctWidthInSubband,\n                precinctHeightInSubband: precinctHeightInSubband\n            };\n        }\n        function buildCodeblocks(context, subband, dimensions) {\n            var xcb_ = dimensions.xcb_;\n            var ycb_ = dimensions.ycb_;\n            var codeblockWidth = 1 << xcb_;\n            var codeblockHeight = 1 << ycb_;\n            var cbx0 = subband.tbx0 >> xcb_;\n            var cby0 = subband.tby0 >> ycb_;\n            var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;\n            var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;\n            var precinctParameters = subband.resolution.precinctParameters;\n            var codeblocks = [];\n            var precincts = [];\n            var i, j, codeblock, precinctNumber;\n            for (j = cby0; j < cby1; j++) {\n                for (i = cbx0; i < cbx1; i++) {\n                    codeblock = {\n                        cbx: i,\n                        cby: j,\n                        tbx0: codeblockWidth * i,\n                        tby0: codeblockHeight * j,\n                        tbx1: codeblockWidth * (i + 1),\n                        tby1: codeblockHeight * (j + 1)\n                    };\n                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);\n                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);\n                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);\n                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);\n                    var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);\n                    var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);\n                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;\n                    codeblock.precinctNumber = precinctNumber;\n                    codeblock.subbandType = subband.type;\n                    codeblock.Lblock = 3;\n                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {\n                        continue;\n                    }\n                    codeblocks.push(codeblock);\n                    var precinct = precincts[precinctNumber];\n                    if (precinct !== undefined) {\n                        if (i < precinct.cbxMin) {\n                            precinct.cbxMin = i;\n                        } else if (i > precinct.cbxMax) {\n                            precinct.cbxMax = i;\n                        }\n                        if (j < precinct.cbyMin) {\n                            precinct.cbxMin = j;\n                        } else if (j > precinct.cbyMax) {\n                            precinct.cbyMax = j;\n                        }\n                    } else {\n                        precincts[precinctNumber] = precinct = {\n                            cbxMin: i,\n                            cbyMin: j,\n                            cbxMax: i,\n                            cbyMax: j\n                        };\n                    }\n                    codeblock.precinct = precinct;\n                }\n            }\n            subband.codeblockParameters = {\n                codeblockWidth: xcb_,\n                codeblockHeight: ycb_,\n                numcodeblockwide: cbx1 - cbx0 + 1,\n                numcodeblockhigh: cby1 - cby0 + 1\n            };\n            subband.codeblocks = codeblocks;\n            subband.precincts = precincts;\n        }\n        function createPacket(resolution, precinctNumber, layerNumber) {\n            var precinctCodeblocks = [];\n            var subbands = resolution.subbands;\n            for (var i = 0, ii = subbands.length; i < ii; i++) {\n                var subband = subbands[i];\n                var codeblocks = subband.codeblocks;\n                for (var j = 0, jj = codeblocks.length; j < jj; j++) {\n                    var codeblock = codeblocks[j];\n                    if (codeblock.precinctNumber !== precinctNumber) {\n                        continue;\n                    }\n                    precinctCodeblocks.push(codeblock);\n                }\n            }\n            return {\n                layerNumber: layerNumber,\n                codeblocks: precinctCodeblocks\n            };\n        }\n        function LayerResolutionComponentPositionIterator(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var layersCount = tile.codingStyleDefaultParameters.layersCount;\n            var componentsCount = siz.Csiz;\n            var maxDecompositionLevelsCount = 0;\n            for (var q = 0; q < componentsCount; q++) {\n                maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);\n            }\n            var l = 0, r = 0, i = 0, k = 0;\n            this.nextPacket = function JpxImage_nextPacket() {\n                for (;l < layersCount; l++) {\n                    for (;r <= maxDecompositionLevelsCount; r++) {\n                        for (;i < componentsCount; i++) {\n                            var component = tile.components[i];\n                            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n                                continue;\n                            }\n                            var resolution = component.resolutions[r];\n                            var numprecincts = resolution.precinctParameters.numprecincts;\n                            for (;k < numprecincts; ) {\n                                var packet = createPacket(resolution, k, l);\n                                k++;\n                                return packet;\n                            }\n                            k = 0;\n                        }\n                        i = 0;\n                    }\n                    r = 0;\n                }\n                throw new Error("JPX Error: Out of packets");\n            };\n        }\n        function ResolutionLayerComponentPositionIterator(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var layersCount = tile.codingStyleDefaultParameters.layersCount;\n            var componentsCount = siz.Csiz;\n            var maxDecompositionLevelsCount = 0;\n            for (var q = 0; q < componentsCount; q++) {\n                maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);\n            }\n            var r = 0, l = 0, i = 0, k = 0;\n            this.nextPacket = function JpxImage_nextPacket() {\n                for (;r <= maxDecompositionLevelsCount; r++) {\n                    for (;l < layersCount; l++) {\n                        for (;i < componentsCount; i++) {\n                            var component = tile.components[i];\n                            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n                                continue;\n                            }\n                            var resolution = component.resolutions[r];\n                            var numprecincts = resolution.precinctParameters.numprecincts;\n                            for (;k < numprecincts; ) {\n                                var packet = createPacket(resolution, k, l);\n                                k++;\n                                return packet;\n                            }\n                            k = 0;\n                        }\n                        i = 0;\n                    }\n                    l = 0;\n                }\n                throw new Error("JPX Error: Out of packets");\n            };\n        }\n        function ResolutionPositionComponentLayerIterator(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var layersCount = tile.codingStyleDefaultParameters.layersCount;\n            var componentsCount = siz.Csiz;\n            var l, r, c, p;\n            var maxDecompositionLevelsCount = 0;\n            for (c = 0; c < componentsCount; c++) {\n                var component = tile.components[c];\n                maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);\n            }\n            var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);\n            for (r = 0; r <= maxDecompositionLevelsCount; ++r) {\n                var maxNumPrecincts = 0;\n                for (c = 0; c < componentsCount; ++c) {\n                    var resolutions = tile.components[c].resolutions;\n                    if (r < resolutions.length) {\n                        maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);\n                    }\n                }\n                maxNumPrecinctsInLevel[r] = maxNumPrecincts;\n            }\n            l = 0;\n            r = 0;\n            c = 0;\n            p = 0;\n            this.nextPacket = function JpxImage_nextPacket() {\n                for (;r <= maxDecompositionLevelsCount; r++) {\n                    for (;p < maxNumPrecinctsInLevel[r]; p++) {\n                        for (;c < componentsCount; c++) {\n                            var component = tile.components[c];\n                            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n                                continue;\n                            }\n                            var resolution = component.resolutions[r];\n                            var numprecincts = resolution.precinctParameters.numprecincts;\n                            if (p >= numprecincts) {\n                                continue;\n                            }\n                            for (;l < layersCount; ) {\n                                var packet = createPacket(resolution, p, l);\n                                l++;\n                                return packet;\n                            }\n                            l = 0;\n                        }\n                        c = 0;\n                    }\n                    p = 0;\n                }\n                throw new Error("JPX Error: Out of packets");\n            };\n        }\n        function PositionComponentResolutionLayerIterator(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var layersCount = tile.codingStyleDefaultParameters.layersCount;\n            var componentsCount = siz.Csiz;\n            var precinctsSizes = getPrecinctSizesInImageScale(tile);\n            var precinctsIterationSizes = precinctsSizes;\n            var l = 0, r = 0, c = 0, px = 0, py = 0;\n            this.nextPacket = function JpxImage_nextPacket() {\n                for (;py < precinctsIterationSizes.maxNumHigh; py++) {\n                    for (;px < precinctsIterationSizes.maxNumWide; px++) {\n                        for (;c < componentsCount; c++) {\n                            var component = tile.components[c];\n                            var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;\n                            for (;r <= decompositionLevelsCount; r++) {\n                                var resolution = component.resolutions[r];\n                                var sizeInImageScale = precinctsSizes.components[c].resolutions[r];\n                                var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);\n                                if (k === null) {\n                                    continue;\n                                }\n                                for (;l < layersCount; ) {\n                                    var packet = createPacket(resolution, k, l);\n                                    l++;\n                                    return packet;\n                                }\n                                l = 0;\n                            }\n                            r = 0;\n                        }\n                        c = 0;\n                    }\n                    px = 0;\n                }\n                throw new Error("JPX Error: Out of packets");\n            };\n        }\n        function ComponentPositionResolutionLayerIterator(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var layersCount = tile.codingStyleDefaultParameters.layersCount;\n            var componentsCount = siz.Csiz;\n            var precinctsSizes = getPrecinctSizesInImageScale(tile);\n            var l = 0, r = 0, c = 0, px = 0, py = 0;\n            this.nextPacket = function JpxImage_nextPacket() {\n                for (;c < componentsCount; ++c) {\n                    var component = tile.components[c];\n                    var precinctsIterationSizes = precinctsSizes.components[c];\n                    var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;\n                    for (;py < precinctsIterationSizes.maxNumHigh; py++) {\n                        for (;px < precinctsIterationSizes.maxNumWide; px++) {\n                            for (;r <= decompositionLevelsCount; r++) {\n                                var resolution = component.resolutions[r];\n                                var sizeInImageScale = precinctsIterationSizes.resolutions[r];\n                                var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);\n                                if (k === null) {\n                                    continue;\n                                }\n                                for (;l < layersCount; ) {\n                                    var packet = createPacket(resolution, k, l);\n                                    l++;\n                                    return packet;\n                                }\n                                l = 0;\n                            }\n                            r = 0;\n                        }\n                        px = 0;\n                    }\n                    py = 0;\n                }\n                throw new Error("JPX Error: Out of packets");\n            };\n        }\n        function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {\n            var posX = pxIndex * precinctIterationSizes.minWidth;\n            var posY = pyIndex * precinctIterationSizes.minHeight;\n            if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {\n                return null;\n            }\n            var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;\n            return posX / sizeInImageScale.height + startPrecinctRowIndex;\n        }\n        function getPrecinctSizesInImageScale(tile) {\n            var componentsCount = tile.components.length;\n            var minWidth = Number.MAX_VALUE;\n            var minHeight = Number.MAX_VALUE;\n            var maxNumWide = 0;\n            var maxNumHigh = 0;\n            var sizePerComponent = new Array(componentsCount);\n            for (var c = 0; c < componentsCount; c++) {\n                var component = tile.components[c];\n                var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;\n                var sizePerResolution = new Array(decompositionLevelsCount + 1);\n                var minWidthCurrentComponent = Number.MAX_VALUE;\n                var minHeightCurrentComponent = Number.MAX_VALUE;\n                var maxNumWideCurrentComponent = 0;\n                var maxNumHighCurrentComponent = 0;\n                var scale = 1;\n                for (var r = decompositionLevelsCount; r >= 0; --r) {\n                    var resolution = component.resolutions[r];\n                    var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;\n                    var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;\n                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);\n                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);\n                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);\n                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);\n                    sizePerResolution[r] = {\n                        width: widthCurrentResolution,\n                        height: heightCurrentResolution\n                    };\n                    scale <<= 1;\n                }\n                minWidth = Math.min(minWidth, minWidthCurrentComponent);\n                minHeight = Math.min(minHeight, minHeightCurrentComponent);\n                maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);\n                maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);\n                sizePerComponent[c] = {\n                    resolutions: sizePerResolution,\n                    minWidth: minWidthCurrentComponent,\n                    minHeight: minHeightCurrentComponent,\n                    maxNumWide: maxNumWideCurrentComponent,\n                    maxNumHigh: maxNumHighCurrentComponent\n                };\n            }\n            return {\n                components: sizePerComponent,\n                minWidth: minWidth,\n                minHeight: minHeight,\n                maxNumWide: maxNumWide,\n                maxNumHigh: maxNumHigh\n            };\n        }\n        function buildPackets(context) {\n            var siz = context.SIZ;\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var componentsCount = siz.Csiz;\n            for (var c = 0; c < componentsCount; c++) {\n                var component = tile.components[c];\n                var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;\n                var resolutions = [];\n                var subbands = [];\n                for (var r = 0; r <= decompositionLevelsCount; r++) {\n                    var blocksDimensions = getBlocksDimensions(context, component, r);\n                    var resolution = {};\n                    var scale = 1 << decompositionLevelsCount - r;\n                    resolution.trx0 = Math.ceil(component.tcx0 / scale);\n                    resolution.try0 = Math.ceil(component.tcy0 / scale);\n                    resolution.trx1 = Math.ceil(component.tcx1 / scale);\n                    resolution.try1 = Math.ceil(component.tcy1 / scale);\n                    resolution.resLevel = r;\n                    buildPrecincts(context, resolution, blocksDimensions);\n                    resolutions.push(resolution);\n                    var subband;\n                    if (r === 0) {\n                        subband = {};\n                        subband.type = "LL";\n                        subband.tbx0 = Math.ceil(component.tcx0 / scale);\n                        subband.tby0 = Math.ceil(component.tcy0 / scale);\n                        subband.tbx1 = Math.ceil(component.tcx1 / scale);\n                        subband.tby1 = Math.ceil(component.tcy1 / scale);\n                        subband.resolution = resolution;\n                        buildCodeblocks(context, subband, blocksDimensions);\n                        subbands.push(subband);\n                        resolution.subbands = [ subband ];\n                    } else {\n                        var bscale = 1 << decompositionLevelsCount - r + 1;\n                        var resolutionSubbands = [];\n                        subband = {};\n                        subband.type = "HL";\n                        subband.tbx0 = Math.ceil(component.tcx0 / bscale - .5);\n                        subband.tby0 = Math.ceil(component.tcy0 / bscale);\n                        subband.tbx1 = Math.ceil(component.tcx1 / bscale - .5);\n                        subband.tby1 = Math.ceil(component.tcy1 / bscale);\n                        subband.resolution = resolution;\n                        buildCodeblocks(context, subband, blocksDimensions);\n                        subbands.push(subband);\n                        resolutionSubbands.push(subband);\n                        subband = {};\n                        subband.type = "LH";\n                        subband.tbx0 = Math.ceil(component.tcx0 / bscale);\n                        subband.tby0 = Math.ceil(component.tcy0 / bscale - .5);\n                        subband.tbx1 = Math.ceil(component.tcx1 / bscale);\n                        subband.tby1 = Math.ceil(component.tcy1 / bscale - .5);\n                        subband.resolution = resolution;\n                        buildCodeblocks(context, subband, blocksDimensions);\n                        subbands.push(subband);\n                        resolutionSubbands.push(subband);\n                        subband = {};\n                        subband.type = "HH";\n                        subband.tbx0 = Math.ceil(component.tcx0 / bscale - .5);\n                        subband.tby0 = Math.ceil(component.tcy0 / bscale - .5);\n                        subband.tbx1 = Math.ceil(component.tcx1 / bscale - .5);\n                        subband.tby1 = Math.ceil(component.tcy1 / bscale - .5);\n                        subband.resolution = resolution;\n                        buildCodeblocks(context, subband, blocksDimensions);\n                        subbands.push(subband);\n                        resolutionSubbands.push(subband);\n                        resolution.subbands = resolutionSubbands;\n                    }\n                }\n                component.resolutions = resolutions;\n                component.subbands = subbands;\n            }\n            var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;\n            switch (progressionOrder) {\n              case 0:\n                tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);\n                break;\n\n              case 1:\n                tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);\n                break;\n\n              case 2:\n                tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);\n                break;\n\n              case 3:\n                tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);\n                break;\n\n              case 4:\n                tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);\n                break;\n\n              default:\n                throw new Error("JPX Error: Unsupported progression order " + progressionOrder);\n            }\n        }\n        function parseTilePackets(context, data, offset, dataLength) {\n            var position = 0;\n            var buffer, bufferSize = 0, skipNextBit = false;\n            function readBits(count) {\n                while (bufferSize < count) {\n                    var b = data[offset + position];\n                    position++;\n                    if (skipNextBit) {\n                        buffer = buffer << 7 | b;\n                        bufferSize += 7;\n                        skipNextBit = false;\n                    } else {\n                        buffer = buffer << 8 | b;\n                        bufferSize += 8;\n                    }\n                    if (b === 255) {\n                        skipNextBit = true;\n                    }\n                }\n                bufferSize -= count;\n                return buffer >>> bufferSize & (1 << count) - 1;\n            }\n            function skipMarkerIfEqual(value) {\n                if (data[offset + position - 1] === 255 && data[offset + position] === value) {\n                    skipBytes(1);\n                    return true;\n                } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {\n                    skipBytes(2);\n                    return true;\n                }\n                return false;\n            }\n            function skipBytes(count) {\n                position += count;\n            }\n            function alignToByte() {\n                bufferSize = 0;\n                if (skipNextBit) {\n                    position++;\n                    skipNextBit = false;\n                }\n            }\n            function readCodingpasses() {\n                if (readBits(1) === 0) {\n                    return 1;\n                }\n                if (readBits(1) === 0) {\n                    return 2;\n                }\n                var value = readBits(2);\n                if (value < 3) {\n                    return value + 3;\n                }\n                value = readBits(5);\n                if (value < 31) {\n                    return value + 6;\n                }\n                value = readBits(7);\n                return value + 37;\n            }\n            var tileIndex = context.currentTile.index;\n            var tile = context.tiles[tileIndex];\n            var sopMarkerUsed = context.COD.sopMarkerUsed;\n            var ephMarkerUsed = context.COD.ephMarkerUsed;\n            var packetsIterator = tile.packetsIterator;\n            while (position < dataLength) {\n                alignToByte();\n                if (sopMarkerUsed && skipMarkerIfEqual(145)) {\n                    skipBytes(4);\n                }\n                var packet = packetsIterator.nextPacket();\n                if (!readBits(1)) {\n                    continue;\n                }\n                var layerNumber = packet.layerNumber;\n                var queue = [], codeblock;\n                for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {\n                    codeblock = packet.codeblocks[i];\n                    var precinct = codeblock.precinct;\n                    var codeblockColumn = codeblock.cbx - precinct.cbxMin;\n                    var codeblockRow = codeblock.cby - precinct.cbyMin;\n                    var codeblockIncluded = false;\n                    var firstTimeInclusion = false;\n                    var valueReady;\n                    if (codeblock["included"] !== undefined) {\n                        codeblockIncluded = !!readBits(1);\n                    } else {\n                        precinct = codeblock.precinct;\n                        var inclusionTree, zeroBitPlanesTree;\n                        if (precinct["inclusionTree"] !== undefined) {\n                            inclusionTree = precinct.inclusionTree;\n                        } else {\n                            var width = precinct.cbxMax - precinct.cbxMin + 1;\n                            var height = precinct.cbyMax - precinct.cbyMin + 1;\n                            inclusionTree = new InclusionTree(width, height, layerNumber);\n                            zeroBitPlanesTree = new TagTree(width, height);\n                            precinct.inclusionTree = inclusionTree;\n                            precinct.zeroBitPlanesTree = zeroBitPlanesTree;\n                        }\n                        if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {\n                            while (true) {\n                                if (readBits(1)) {\n                                    valueReady = !inclusionTree.nextLevel();\n                                    if (valueReady) {\n                                        codeblock.included = true;\n                                        codeblockIncluded = firstTimeInclusion = true;\n                                        break;\n                                    }\n                                } else {\n                                    inclusionTree.incrementValue(layerNumber);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if (!codeblockIncluded) {\n                        continue;\n                    }\n                    if (firstTimeInclusion) {\n                        zeroBitPlanesTree = precinct.zeroBitPlanesTree;\n                        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);\n                        while (true) {\n                            if (readBits(1)) {\n                                valueReady = !zeroBitPlanesTree.nextLevel();\n                                if (valueReady) {\n                                    break;\n                                }\n                            } else {\n                                zeroBitPlanesTree.incrementValue();\n                            }\n                        }\n                        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;\n                    }\n                    var codingpasses = readCodingpasses();\n                    while (readBits(1)) {\n                        codeblock.Lblock++;\n                    }\n                    var codingpassesLog2 = log2(codingpasses);\n                    var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;\n                    var codedDataLength = readBits(bits);\n                    queue.push({\n                        codeblock: codeblock,\n                        codingpasses: codingpasses,\n                        dataLength: codedDataLength\n                    });\n                }\n                alignToByte();\n                if (ephMarkerUsed) {\n                    skipMarkerIfEqual(146);\n                }\n                while (queue.length > 0) {\n                    var packetItem = queue.shift();\n                    codeblock = packetItem.codeblock;\n                    if (codeblock["data"] === undefined) {\n                        codeblock.data = [];\n                    }\n                    codeblock.data.push({\n                        data: data,\n                        start: offset + position,\n                        end: offset + position + packetItem.dataLength,\n                        codingpasses: packetItem.codingpasses\n                    });\n                    position += packetItem.dataLength;\n                }\n            }\n            return position;\n        }\n        function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {\n            var x0 = subband.tbx0;\n            var y0 = subband.tby0;\n            var width = subband.tbx1 - subband.tbx0;\n            var codeblocks = subband.codeblocks;\n            var right = subband.type.charAt(0) === "H" ? 1 : 0;\n            var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;\n            for (var i = 0, ii = codeblocks.length; i < ii; ++i) {\n                var codeblock = codeblocks[i];\n                var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;\n                var blockHeight = codeblock.tby1_ - codeblock.tby0_;\n                if (blockWidth === 0 || blockHeight === 0) {\n                    continue;\n                }\n                if (codeblock["data"] === undefined) {\n                    continue;\n                }\n                var bitModel, currentCodingpassType;\n                bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);\n                currentCodingpassType = 2;\n                var data = codeblock.data, totalLength = 0, codingpasses = 0;\n                var j, jj, dataItem;\n                for (j = 0, jj = data.length; j < jj; j++) {\n                    dataItem = data[j];\n                    totalLength += dataItem.end - dataItem.start;\n                    codingpasses += dataItem.codingpasses;\n                }\n                var encodedData = new Uint8Array(totalLength);\n                var position = 0;\n                for (j = 0, jj = data.length; j < jj; j++) {\n                    dataItem = data[j];\n                    var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);\n                    encodedData.set(chunk, position);\n                    position += chunk.length;\n                }\n                var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);\n                bitModel.setDecoder(decoder);\n                for (j = 0; j < codingpasses; j++) {\n                    switch (currentCodingpassType) {\n                      case 0:\n                        bitModel.runSignificancePropogationPass();\n                        break;\n\n                      case 1:\n                        bitModel.runMagnitudeRefinementPass();\n                        break;\n\n                      case 2:\n                        bitModel.runCleanupPass();\n                        if (segmentationSymbolUsed) {\n                            bitModel.checkSegmentationSymbol();\n                        }\n                        break;\n                    }\n                    currentCodingpassType = (currentCodingpassType + 1) % 3;\n                }\n                var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;\n                var sign = bitModel.coefficentsSign;\n                var magnitude = bitModel.coefficentsMagnitude;\n                var bitsDecoded = bitModel.bitsDecoded;\n                var magnitudeCorrection = reversible ? 0 : .5;\n                var k, n, nb;\n                position = 0;\n                var interleave = subband.type !== "LL";\n                for (j = 0; j < blockHeight; j++) {\n                    var row = offset / width | 0;\n                    var levelOffset = 2 * row * (levelWidth - width) + right + bottom;\n                    for (k = 0; k < blockWidth; k++) {\n                        n = magnitude[position];\n                        if (n !== 0) {\n                            n = (n + magnitudeCorrection) * delta;\n                            if (sign[position] !== 0) {\n                                n = -n;\n                            }\n                            nb = bitsDecoded[position];\n                            var pos = interleave ? levelOffset + (offset << 1) : offset;\n                            if (reversible && nb >= mb) {\n                                coefficients[pos] = n;\n                            } else {\n                                coefficients[pos] = n * (1 << mb - nb);\n                            }\n                        }\n                        offset++;\n                        position++;\n                    }\n                    offset += width - blockWidth;\n                }\n            }\n        }\n        function transformTile(context, tile, c) {\n            var component = tile.components[c];\n            var codingStyleParameters = component.codingStyleParameters;\n            var quantizationParameters = component.quantizationParameters;\n            var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;\n            var spqcds = quantizationParameters.SPqcds;\n            var scalarExpounded = quantizationParameters.scalarExpounded;\n            var guardBits = quantizationParameters.guardBits;\n            var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;\n            var precision = context.components[c].precision;\n            var reversible = codingStyleParameters.reversibleTransformation;\n            var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();\n            var subbandCoefficients = [];\n            var b = 0;\n            for (var i = 0; i <= decompositionLevelsCount; i++) {\n                var resolution = component.resolutions[i];\n                var width = resolution.trx1 - resolution.trx0;\n                var height = resolution.try1 - resolution.try0;\n                var coefficients = new Float32Array(width * height);\n                for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {\n                    var mu, epsilon;\n                    if (!scalarExpounded) {\n                        mu = spqcds[0].mu;\n                        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);\n                    } else {\n                        mu = spqcds[b].mu;\n                        epsilon = spqcds[b].epsilon;\n                        b++;\n                    }\n                    var subband = resolution.subbands[j];\n                    var gainLog2 = SubbandsGainLog2[subband.type];\n                    var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);\n                    var mb = guardBits + epsilon - 1;\n                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);\n                }\n                subbandCoefficients.push({\n                    width: width,\n                    height: height,\n                    items: coefficients\n                });\n            }\n            var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);\n            return {\n                left: component.tcx0,\n                top: component.tcy0,\n                width: result.width,\n                height: result.height,\n                items: result.items\n            };\n        }\n        function transformComponents(context) {\n            var siz = context.SIZ;\n            var components = context.components;\n            var componentsCount = siz.Csiz;\n            var resultImages = [];\n            for (var i = 0, ii = context.tiles.length; i < ii; i++) {\n                var tile = context.tiles[i];\n                var transformedTiles = [];\n                var c;\n                for (c = 0; c < componentsCount; c++) {\n                    transformedTiles[c] = transformTile(context, tile, c);\n                }\n                var tile0 = transformedTiles[0];\n                var out = new Uint8Array(tile0.items.length * componentsCount);\n                var result = {\n                    left: tile0.left,\n                    top: tile0.top,\n                    width: tile0.width,\n                    height: tile0.height,\n                    items: out\n                };\n                var shift, offset, max, min, maxK;\n                var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;\n                if (tile.codingStyleDefaultParameters.multipleComponentTransform) {\n                    var fourComponents = componentsCount === 4;\n                    var y0items = transformedTiles[0].items;\n                    var y1items = transformedTiles[1].items;\n                    var y2items = transformedTiles[2].items;\n                    var y3items = fourComponents ? transformedTiles[3].items : null;\n                    shift = components[0].precision - 8;\n                    offset = (128 << shift) + .5;\n                    max = 255 * (1 << shift);\n                    maxK = max * .5;\n                    min = -maxK;\n                    var component0 = tile.components[0];\n                    var alpha01 = componentsCount - 3;\n                    jj = y0items.length;\n                    if (!component0.codingStyleParameters.reversibleTransformation) {\n                        for (j = 0; j < jj; j++, pos += alpha01) {\n                            y0 = y0items[j] + offset;\n                            y1 = y1items[j];\n                            y2 = y2items[j];\n                            r = y0 + 1.402 * y2;\n                            g = y0 - .34413 * y1 - .71414 * y2;\n                            b = y0 + 1.772 * y1;\n                            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;\n                            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;\n                            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;\n                        }\n                    } else {\n                        for (j = 0; j < jj; j++, pos += alpha01) {\n                            y0 = y0items[j] + offset;\n                            y1 = y1items[j];\n                            y2 = y2items[j];\n                            g = y0 - (y2 + y1 >> 2);\n                            r = g + y2;\n                            b = g + y1;\n                            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;\n                            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;\n                            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;\n                        }\n                    }\n                    if (fourComponents) {\n                        for (j = 0, pos = 3; j < jj; j++, pos += 4) {\n                            k = y3items[j];\n                            out[pos] = k <= min ? 0 : k >= maxK ? 255 : k + offset >> shift;\n                        }\n                    }\n                } else {\n                    for (c = 0; c < componentsCount; c++) {\n                        var items = transformedTiles[c].items;\n                        shift = components[c].precision - 8;\n                        offset = (128 << shift) + .5;\n                        max = 127.5 * (1 << shift);\n                        min = -max;\n                        for (pos = c, j = 0, jj = items.length; j < jj; j++) {\n                            val = items[j];\n                            out[pos] = val <= min ? 0 : val >= max ? 255 : val + offset >> shift;\n                            pos += componentsCount;\n                        }\n                    }\n                }\n                resultImages.push(result);\n            }\n            return resultImages;\n        }\n        function initializeTile(context, tileIndex) {\n            var siz = context.SIZ;\n            var componentsCount = siz.Csiz;\n            var tile = context.tiles[tileIndex];\n            for (var c = 0; c < componentsCount; c++) {\n                var component = tile.components[c];\n                var qcdOrQcc = context.currentTile.QCC[c] !== undefined ? context.currentTile.QCC[c] : context.currentTile.QCD;\n                component.quantizationParameters = qcdOrQcc;\n                var codOrCoc = context.currentTile.COC[c] !== undefined ? context.currentTile.COC[c] : context.currentTile.COD;\n                component.codingStyleParameters = codOrCoc;\n            }\n            tile.codingStyleDefaultParameters = context.currentTile.COD;\n        }\n        var TagTree = function TagTreeClosure() {\n            function TagTree(width, height) {\n                var levelsLength = log2(Math.max(width, height)) + 1;\n                this.levels = [];\n                for (var i = 0; i < levelsLength; i++) {\n                    var level = {\n                        width: width,\n                        height: height,\n                        items: []\n                    };\n                    this.levels.push(level);\n                    width = Math.ceil(width / 2);\n                    height = Math.ceil(height / 2);\n                }\n            }\n            TagTree.prototype = {\n                reset: function TagTree_reset(i, j) {\n                    var currentLevel = 0, value = 0, level;\n                    while (currentLevel < this.levels.length) {\n                        level = this.levels[currentLevel];\n                        var index = i + j * level.width;\n                        if (level.items[index] !== undefined) {\n                            value = level.items[index];\n                            break;\n                        }\n                        level.index = index;\n                        i >>= 1;\n                        j >>= 1;\n                        currentLevel++;\n                    }\n                    currentLevel--;\n                    level = this.levels[currentLevel];\n                    level.items[level.index] = value;\n                    this.currentLevel = currentLevel;\n                    delete this.value;\n                },\n                incrementValue: function TagTree_incrementValue() {\n                    var level = this.levels[this.currentLevel];\n                    level.items[level.index]++;\n                },\n                nextLevel: function TagTree_nextLevel() {\n                    var currentLevel = this.currentLevel;\n                    var level = this.levels[currentLevel];\n                    var value = level.items[level.index];\n                    currentLevel--;\n                    if (currentLevel < 0) {\n                        this.value = value;\n                        return false;\n                    }\n                    this.currentLevel = currentLevel;\n                    level = this.levels[currentLevel];\n                    level.items[level.index] = value;\n                    return true;\n                }\n            };\n            return TagTree;\n        }();\n        var InclusionTree = function InclusionTreeClosure() {\n            function InclusionTree(width, height, defaultValue) {\n                var levelsLength = log2(Math.max(width, height)) + 1;\n                this.levels = [];\n                for (var i = 0; i < levelsLength; i++) {\n                    var items = new Uint8Array(width * height);\n                    for (var j = 0, jj = items.length; j < jj; j++) {\n                        items[j] = defaultValue;\n                    }\n                    var level = {\n                        width: width,\n                        height: height,\n                        items: items\n                    };\n                    this.levels.push(level);\n                    width = Math.ceil(width / 2);\n                    height = Math.ceil(height / 2);\n                }\n            }\n            InclusionTree.prototype = {\n                reset: function InclusionTree_reset(i, j, stopValue) {\n                    var currentLevel = 0;\n                    while (currentLevel < this.levels.length) {\n                        var level = this.levels[currentLevel];\n                        var index = i + j * level.width;\n                        level.index = index;\n                        var value = level.items[index];\n                        if (value === 255) {\n                            break;\n                        }\n                        if (value > stopValue) {\n                            this.currentLevel = currentLevel;\n                            this.propagateValues();\n                            return false;\n                        }\n                        i >>= 1;\n                        j >>= 1;\n                        currentLevel++;\n                    }\n                    this.currentLevel = currentLevel - 1;\n                    return true;\n                },\n                incrementValue: function InclusionTree_incrementValue(stopValue) {\n                    var level = this.levels[this.currentLevel];\n                    level.items[level.index] = stopValue + 1;\n                    this.propagateValues();\n                },\n                propagateValues: function InclusionTree_propagateValues() {\n                    var levelIndex = this.currentLevel;\n                    var level = this.levels[levelIndex];\n                    var currentValue = level.items[level.index];\n                    while (--levelIndex >= 0) {\n                        level = this.levels[levelIndex];\n                        level.items[level.index] = currentValue;\n                    }\n                },\n                nextLevel: function InclusionTree_nextLevel() {\n                    var currentLevel = this.currentLevel;\n                    var level = this.levels[currentLevel];\n                    var value = level.items[level.index];\n                    level.items[level.index] = 255;\n                    currentLevel--;\n                    if (currentLevel < 0) {\n                        return false;\n                    }\n                    this.currentLevel = currentLevel;\n                    level = this.levels[currentLevel];\n                    level.items[level.index] = value;\n                    return true;\n                }\n            };\n            return InclusionTree;\n        }();\n        var BitModel = function BitModelClosure() {\n            var UNIFORM_CONTEXT = 17;\n            var RUNLENGTH_CONTEXT = 18;\n            var LLAndLHContextsLabel = new Uint8Array([ 0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8 ]);\n            var HLContextLabel = new Uint8Array([ 0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8 ]);\n            var HHContextLabel = new Uint8Array([ 0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8 ]);\n            function BitModel(width, height, subband, zeroBitPlanes, mb) {\n                this.width = width;\n                this.height = height;\n                this.contextLabelTable = subband === "HH" ? HHContextLabel : subband === "HL" ? HLContextLabel : LLAndLHContextsLabel;\n                var coefficientCount = width * height;\n                this.neighborsSignificance = new Uint8Array(coefficientCount);\n                this.coefficentsSign = new Uint8Array(coefficientCount);\n                this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);\n                this.processingFlags = new Uint8Array(coefficientCount);\n                var bitsDecoded = new Uint8Array(coefficientCount);\n                if (zeroBitPlanes !== 0) {\n                    for (var i = 0; i < coefficientCount; i++) {\n                        bitsDecoded[i] = zeroBitPlanes;\n                    }\n                }\n                this.bitsDecoded = bitsDecoded;\n                this.reset();\n            }\n            BitModel.prototype = {\n                setDecoder: function BitModel_setDecoder(decoder) {\n                    this.decoder = decoder;\n                },\n                reset: function BitModel_reset() {\n                    this.contexts = new Int8Array(19);\n                    this.contexts[0] = 4 << 1 | 0;\n                    this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;\n                    this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;\n                },\n                setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {\n                    var neighborsSignificance = this.neighborsSignificance;\n                    var width = this.width, height = this.height;\n                    var left = column > 0;\n                    var right = column + 1 < width;\n                    var i;\n                    if (row > 0) {\n                        i = index - width;\n                        if (left) {\n                            neighborsSignificance[i - 1] += 16;\n                        }\n                        if (right) {\n                            neighborsSignificance[i + 1] += 16;\n                        }\n                        neighborsSignificance[i] += 4;\n                    }\n                    if (row + 1 < height) {\n                        i = index + width;\n                        if (left) {\n                            neighborsSignificance[i - 1] += 16;\n                        }\n                        if (right) {\n                            neighborsSignificance[i + 1] += 16;\n                        }\n                        neighborsSignificance[i] += 4;\n                    }\n                    if (left) {\n                        neighborsSignificance[index - 1] += 1;\n                    }\n                    if (right) {\n                        neighborsSignificance[index + 1] += 1;\n                    }\n                    neighborsSignificance[index] |= 128;\n                },\n                runSignificancePropogationPass: function BitModel_runSignificancePropogationPass() {\n                    var decoder = this.decoder;\n                    var width = this.width, height = this.height;\n                    var coefficentsMagnitude = this.coefficentsMagnitude;\n                    var coefficentsSign = this.coefficentsSign;\n                    var neighborsSignificance = this.neighborsSignificance;\n                    var processingFlags = this.processingFlags;\n                    var contexts = this.contexts;\n                    var labels = this.contextLabelTable;\n                    var bitsDecoded = this.bitsDecoded;\n                    var processedInverseMask = ~1;\n                    var processedMask = 1;\n                    var firstMagnitudeBitMask = 2;\n                    for (var i0 = 0; i0 < height; i0 += 4) {\n                        for (var j = 0; j < width; j++) {\n                            var index = i0 * width + j;\n                            for (var i1 = 0; i1 < 4; i1++, index += width) {\n                                var i = i0 + i1;\n                                if (i >= height) {\n                                    break;\n                                }\n                                processingFlags[index] &= processedInverseMask;\n                                if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {\n                                    continue;\n                                }\n                                var contextLabel = labels[neighborsSignificance[index]];\n                                var decision = decoder.readBit(contexts, contextLabel);\n                                if (decision) {\n                                    var sign = this.decodeSignBit(i, j, index);\n                                    coefficentsSign[index] = sign;\n                                    coefficentsMagnitude[index] = 1;\n                                    this.setNeighborsSignificance(i, j, index);\n                                    processingFlags[index] |= firstMagnitudeBitMask;\n                                }\n                                bitsDecoded[index]++;\n                                processingFlags[index] |= processedMask;\n                            }\n                        }\n                    }\n                },\n                decodeSignBit: function BitModel_decodeSignBit(row, column, index) {\n                    var width = this.width, height = this.height;\n                    var coefficentsMagnitude = this.coefficentsMagnitude;\n                    var coefficentsSign = this.coefficentsSign;\n                    var contribution, sign0, sign1, significance1;\n                    var contextLabel, decoded;\n                    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;\n                    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {\n                        sign1 = coefficentsSign[index + 1];\n                        if (significance1) {\n                            sign0 = coefficentsSign[index - 1];\n                            contribution = 1 - sign1 - sign0;\n                        } else {\n                            contribution = 1 - sign1 - sign1;\n                        }\n                    } else if (significance1) {\n                        sign0 = coefficentsSign[index - 1];\n                        contribution = 1 - sign0 - sign0;\n                    } else {\n                        contribution = 0;\n                    }\n                    var horizontalContribution = 3 * contribution;\n                    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;\n                    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {\n                        sign1 = coefficentsSign[index + width];\n                        if (significance1) {\n                            sign0 = coefficentsSign[index - width];\n                            contribution = 1 - sign1 - sign0 + horizontalContribution;\n                        } else {\n                            contribution = 1 - sign1 - sign1 + horizontalContribution;\n                        }\n                    } else if (significance1) {\n                        sign0 = coefficentsSign[index - width];\n                        contribution = 1 - sign0 - sign0 + horizontalContribution;\n                    } else {\n                        contribution = horizontalContribution;\n                    }\n                    if (contribution >= 0) {\n                        contextLabel = 9 + contribution;\n                        decoded = this.decoder.readBit(this.contexts, contextLabel);\n                    } else {\n                        contextLabel = 9 - contribution;\n                        decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;\n                    }\n                    return decoded;\n                },\n                runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {\n                    var decoder = this.decoder;\n                    var width = this.width, height = this.height;\n                    var coefficentsMagnitude = this.coefficentsMagnitude;\n                    var neighborsSignificance = this.neighborsSignificance;\n                    var contexts = this.contexts;\n                    var bitsDecoded = this.bitsDecoded;\n                    var processingFlags = this.processingFlags;\n                    var processedMask = 1;\n                    var firstMagnitudeBitMask = 2;\n                    var length = width * height;\n                    var width4 = width * 4;\n                    for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {\n                        indexNext = Math.min(length, index0 + width4);\n                        for (var j = 0; j < width; j++) {\n                            for (var index = index0 + j; index < indexNext; index += width) {\n                                if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {\n                                    continue;\n                                }\n                                var contextLabel = 16;\n                                if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {\n                                    processingFlags[index] ^= firstMagnitudeBitMask;\n                                    var significance = neighborsSignificance[index] & 127;\n                                    contextLabel = significance === 0 ? 15 : 14;\n                                }\n                                var bit = decoder.readBit(contexts, contextLabel);\n                                coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;\n                                bitsDecoded[index]++;\n                                processingFlags[index] |= processedMask;\n                            }\n                        }\n                    }\n                },\n                runCleanupPass: function BitModel_runCleanupPass() {\n                    var decoder = this.decoder;\n                    var width = this.width, height = this.height;\n                    var neighborsSignificance = this.neighborsSignificance;\n                    var coefficentsMagnitude = this.coefficentsMagnitude;\n                    var coefficentsSign = this.coefficentsSign;\n                    var contexts = this.contexts;\n                    var labels = this.contextLabelTable;\n                    var bitsDecoded = this.bitsDecoded;\n                    var processingFlags = this.processingFlags;\n                    var processedMask = 1;\n                    var firstMagnitudeBitMask = 2;\n                    var oneRowDown = width;\n                    var twoRowsDown = width * 2;\n                    var threeRowsDown = width * 3;\n                    var iNext;\n                    for (var i0 = 0; i0 < height; i0 = iNext) {\n                        iNext = Math.min(i0 + 4, height);\n                        var indexBase = i0 * width;\n                        var checkAllEmpty = i0 + 3 < height;\n                        for (var j = 0; j < width; j++) {\n                            var index0 = indexBase + j;\n                            var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;\n                            var i1 = 0, index = index0;\n                            var i = i0, sign;\n                            if (allEmpty) {\n                                var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);\n                                if (!hasSignificantCoefficent) {\n                                    bitsDecoded[index0]++;\n                                    bitsDecoded[index0 + oneRowDown]++;\n                                    bitsDecoded[index0 + twoRowsDown]++;\n                                    bitsDecoded[index0 + threeRowsDown]++;\n                                    continue;\n                                }\n                                i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);\n                                if (i1 !== 0) {\n                                    i = i0 + i1;\n                                    index += i1 * width;\n                                }\n                                sign = this.decodeSignBit(i, j, index);\n                                coefficentsSign[index] = sign;\n                                coefficentsMagnitude[index] = 1;\n                                this.setNeighborsSignificance(i, j, index);\n                                processingFlags[index] |= firstMagnitudeBitMask;\n                                index = index0;\n                                for (var i2 = i0; i2 <= i; i2++, index += width) {\n                                    bitsDecoded[index]++;\n                                }\n                                i1++;\n                            }\n                            for (i = i0 + i1; i < iNext; i++, index += width) {\n                                if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {\n                                    continue;\n                                }\n                                var contextLabel = labels[neighborsSignificance[index]];\n                                var decision = decoder.readBit(contexts, contextLabel);\n                                if (decision === 1) {\n                                    sign = this.decodeSignBit(i, j, index);\n                                    coefficentsSign[index] = sign;\n                                    coefficentsMagnitude[index] = 1;\n                                    this.setNeighborsSignificance(i, j, index);\n                                    processingFlags[index] |= firstMagnitudeBitMask;\n                                }\n                                bitsDecoded[index]++;\n                            }\n                        }\n                    }\n                },\n                checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {\n                    var decoder = this.decoder;\n                    var contexts = this.contexts;\n                    var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);\n                    if (symbol !== 10) {\n                        throw new Error("JPX Error: Invalid segmentation symbol");\n                    }\n                }\n            };\n            return BitModel;\n        }();\n        var Transform = function TransformClosure() {\n            function Transform() {}\n            Transform.prototype.calculate = function transformCalculate(subbands, u0, v0) {\n                var ll = subbands[0];\n                for (var i = 1, ii = subbands.length; i < ii; i++) {\n                    ll = this.iterate(ll, subbands[i], u0, v0);\n                }\n                return ll;\n            };\n            Transform.prototype.extend = function extend(buffer, offset, size) {\n                var i1 = offset - 1, j1 = offset + 1;\n                var i2 = offset + size - 2, j2 = offset + size;\n                buffer[i1--] = buffer[j1++];\n                buffer[j2++] = buffer[i2--];\n                buffer[i1--] = buffer[j1++];\n                buffer[j2++] = buffer[i2--];\n                buffer[i1--] = buffer[j1++];\n                buffer[j2++] = buffer[i2--];\n                buffer[i1] = buffer[j1];\n                buffer[j2] = buffer[i2];\n            };\n            Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {\n                var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;\n                var width = hl_lh_hh.width;\n                var height = hl_lh_hh.height;\n                var items = hl_lh_hh.items;\n                var i, j, k, l, u, v;\n                for (k = 0, i = 0; i < llHeight; i++) {\n                    l = i * 2 * width;\n                    for (j = 0; j < llWidth; j++, k++, l += 2) {\n                        items[l] = llItems[k];\n                    }\n                }\n                llItems = ll.items = null;\n                var bufferPadding = 4;\n                var rowBuffer = new Float32Array(width + 2 * bufferPadding);\n                if (width === 1) {\n                    if ((u0 & 1) !== 0) {\n                        for (v = 0, k = 0; v < height; v++, k += width) {\n                            items[k] *= .5;\n                        }\n                    }\n                } else {\n                    for (v = 0, k = 0; v < height; v++, k += width) {\n                        rowBuffer.set(items.subarray(k, k + width), bufferPadding);\n                        this.extend(rowBuffer, bufferPadding, width);\n                        this.filter(rowBuffer, bufferPadding, width);\n                        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);\n                    }\n                }\n                var numBuffers = 16;\n                var colBuffers = [];\n                for (i = 0; i < numBuffers; i++) {\n                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));\n                }\n                var b, currentBuffer = 0;\n                ll = bufferPadding + height;\n                if (height === 1) {\n                    if ((v0 & 1) !== 0) {\n                        for (u = 0; u < width; u++) {\n                            items[u] *= .5;\n                        }\n                    }\n                } else {\n                    for (u = 0; u < width; u++) {\n                        if (currentBuffer === 0) {\n                            numBuffers = Math.min(width - u, numBuffers);\n                            for (k = u, l = bufferPadding; l < ll; k += width, l++) {\n                                for (b = 0; b < numBuffers; b++) {\n                                    colBuffers[b][l] = items[k + b];\n                                }\n                            }\n                            currentBuffer = numBuffers;\n                        }\n                        currentBuffer--;\n                        var buffer = colBuffers[currentBuffer];\n                        this.extend(buffer, bufferPadding, height);\n                        this.filter(buffer, bufferPadding, height);\n                        if (currentBuffer === 0) {\n                            k = u - numBuffers + 1;\n                            for (l = bufferPadding; l < ll; k += width, l++) {\n                                for (b = 0; b < numBuffers; b++) {\n                                    items[k + b] = colBuffers[b][l];\n                                }\n                            }\n                        }\n                    }\n                }\n                return {\n                    width: width,\n                    height: height,\n                    items: items\n                };\n            };\n            return Transform;\n        }();\n        var IrreversibleTransform = function IrreversibleTransformClosure() {\n            function IrreversibleTransform() {\n                Transform.call(this);\n            }\n            IrreversibleTransform.prototype = Object.create(Transform.prototype);\n            IrreversibleTransform.prototype.filter = function irreversibleTransformFilter(x, offset, length) {\n                var len = length >> 1;\n                offset = offset | 0;\n                var j, n, current, next;\n                var alpha = -1.586134342059924;\n                var beta = -.052980118572961;\n                var gamma = .882911075530934;\n                var delta = .443506852043971;\n                var K = 1.230174104914001;\n                var K_ = 1 / K;\n                j = offset - 3;\n                for (n = len + 4; n--; j += 2) {\n                    x[j] *= K_;\n                }\n                j = offset - 2;\n                current = delta * x[j - 1];\n                for (n = len + 3; n--; j += 2) {\n                    next = delta * x[j + 1];\n                    x[j] = K * x[j] - current - next;\n                    if (n--) {\n                        j += 2;\n                        current = delta * x[j + 1];\n                        x[j] = K * x[j] - current - next;\n                    } else {\n                        break;\n                    }\n                }\n                j = offset - 1;\n                current = gamma * x[j - 1];\n                for (n = len + 2; n--; j += 2) {\n                    next = gamma * x[j + 1];\n                    x[j] -= current + next;\n                    if (n--) {\n                        j += 2;\n                        current = gamma * x[j + 1];\n                        x[j] -= current + next;\n                    } else {\n                        break;\n                    }\n                }\n                j = offset;\n                current = beta * x[j - 1];\n                for (n = len + 1; n--; j += 2) {\n                    next = beta * x[j + 1];\n                    x[j] -= current + next;\n                    if (n--) {\n                        j += 2;\n                        current = beta * x[j + 1];\n                        x[j] -= current + next;\n                    } else {\n                        break;\n                    }\n                }\n                if (len !== 0) {\n                    j = offset + 1;\n                    current = alpha * x[j - 1];\n                    for (n = len; n--; j += 2) {\n                        next = alpha * x[j + 1];\n                        x[j] -= current + next;\n                        if (n--) {\n                            j += 2;\n                            current = alpha * x[j + 1];\n                            x[j] -= current + next;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            };\n            return IrreversibleTransform;\n        }();\n        var ReversibleTransform = function ReversibleTransformClosure() {\n            function ReversibleTransform() {\n                Transform.call(this);\n            }\n            ReversibleTransform.prototype = Object.create(Transform.prototype);\n            ReversibleTransform.prototype.filter = function reversibleTransformFilter(x, offset, length) {\n                var len = length >> 1;\n                offset = offset | 0;\n                var j, n;\n                for (j = offset, n = len + 1; n--; j += 2) {\n                    x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;\n                }\n                for (j = offset + 1, n = len; n--; j += 2) {\n                    x[j] += x[j - 1] + x[j + 1] >> 1;\n                }\n            };\n            return ReversibleTransform;\n        }();\n        return JpxImage;\n    }();\n    "use strict";\n    var Jbig2Image = function Jbig2ImageClosure() {\n        function ContextCache() {}\n        ContextCache.prototype = {\n            getContexts: function(id) {\n                if (id in this) {\n                    return this[id];\n                }\n                return this[id] = new Int8Array(1 << 16);\n            }\n        };\n        function DecodingContext(data, start, end) {\n            this.data = data;\n            this.start = start;\n            this.end = end;\n        }\n        DecodingContext.prototype = {\n            get decoder() {\n                var decoder = new ArithmeticDecoder(this.data, this.start, this.end);\n                return shadow(this, "decoder", decoder);\n            },\n            get contextCache() {\n                var cache = new ContextCache();\n                return shadow(this, "contextCache", cache);\n            }\n        };\n        function decodeInteger(contextCache, procedure, decoder) {\n            var contexts = contextCache.getContexts(procedure);\n            var prev = 1;\n            function readBits(length) {\n                var v = 0;\n                for (var i = 0; i < length; i++) {\n                    var bit = decoder.readBit(contexts, prev);\n                    prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;\n                    v = v << 1 | bit;\n                }\n                return v >>> 0;\n            }\n            var sign = readBits(1);\n            var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);\n            return sign === 0 ? value : value > 0 ? -value : null;\n        }\n        function decodeIAID(contextCache, decoder, codeLength) {\n            var contexts = contextCache.getContexts("IAID");\n            var prev = 1;\n            for (var i = 0; i < codeLength; i++) {\n                var bit = decoder.readBit(contexts, prev);\n                prev = prev << 1 | bit;\n            }\n            if (codeLength < 31) {\n                return prev & (1 << codeLength) - 1;\n            }\n            return prev & 2147483647;\n        }\n        var SegmentTypes = [ "SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "patternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension" ];\n        var CodingTemplates = [ [ {\n            x: -1,\n            y: -2\n        }, {\n            x: 0,\n            y: -2\n        }, {\n            x: 1,\n            y: -2\n        }, {\n            x: -2,\n            y: -1\n        }, {\n            x: -1,\n            y: -1\n        }, {\n            x: 0,\n            y: -1\n        }, {\n            x: 1,\n            y: -1\n        }, {\n            x: 2,\n            y: -1\n        }, {\n            x: -4,\n            y: 0\n        }, {\n            x: -3,\n            y: 0\n        }, {\n            x: -2,\n            y: 0\n        }, {\n            x: -1,\n            y: 0\n        } ], [ {\n            x: -1,\n            y: -2\n        }, {\n            x: 0,\n            y: -2\n        }, {\n            x: 1,\n            y: -2\n        }, {\n            x: 2,\n            y: -2\n        }, {\n            x: -2,\n            y: -1\n        }, {\n            x: -1,\n            y: -1\n        }, {\n            x: 0,\n            y: -1\n        }, {\n            x: 1,\n            y: -1\n        }, {\n            x: 2,\n            y: -1\n        }, {\n            x: -3,\n            y: 0\n        }, {\n            x: -2,\n            y: 0\n        }, {\n            x: -1,\n            y: 0\n        } ], [ {\n            x: -1,\n            y: -2\n        }, {\n            x: 0,\n            y: -2\n        }, {\n            x: 1,\n            y: -2\n        }, {\n            x: -2,\n            y: -1\n        }, {\n            x: -1,\n            y: -1\n        }, {\n            x: 0,\n            y: -1\n        }, {\n            x: 1,\n            y: -1\n        }, {\n            x: -2,\n            y: 0\n        }, {\n            x: -1,\n            y: 0\n        } ], [ {\n            x: -3,\n            y: -1\n        }, {\n            x: -2,\n            y: -1\n        }, {\n            x: -1,\n            y: -1\n        }, {\n            x: 0,\n            y: -1\n        }, {\n            x: 1,\n            y: -1\n        }, {\n            x: -4,\n            y: 0\n        }, {\n            x: -3,\n            y: 0\n        }, {\n            x: -2,\n            y: 0\n        }, {\n            x: -1,\n            y: 0\n        } ] ];\n        var RefinementTemplates = [ {\n            coding: [ {\n                x: 0,\n                y: -1\n            }, {\n                x: 1,\n                y: -1\n            }, {\n                x: -1,\n                y: 0\n            } ],\n            reference: [ {\n                x: 0,\n                y: -1\n            }, {\n                x: 1,\n                y: -1\n            }, {\n                x: -1,\n                y: 0\n            }, {\n                x: 0,\n                y: 0\n            }, {\n                x: 1,\n                y: 0\n            }, {\n                x: -1,\n                y: 1\n            }, {\n                x: 0,\n                y: 1\n            }, {\n                x: 1,\n                y: 1\n            } ]\n        }, {\n            coding: [ {\n                x: -1,\n                y: -1\n            }, {\n                x: 0,\n                y: -1\n            }, {\n                x: 1,\n                y: -1\n            }, {\n                x: -1,\n                y: 0\n            } ],\n            reference: [ {\n                x: 0,\n                y: -1\n            }, {\n                x: -1,\n                y: 0\n            }, {\n                x: 0,\n                y: 0\n            }, {\n                x: 1,\n                y: 0\n            }, {\n                x: 0,\n                y: 1\n            }, {\n                x: 1,\n                y: 1\n            } ]\n        } ];\n        var ReusedContexts = [ 39717, 1941, 229, 405 ];\n        var RefinementReusedContexts = [ 32, 8 ];\n        function decodeBitmapTemplate0(width, height, decodingContext) {\n            var decoder = decodingContext.decoder;\n            var contexts = decodingContext.contextCache.getContexts("GB");\n            var contextLabel, i, j, pixel, row, row1, row2, bitmap = [];\n            var OLD_PIXEL_MASK = 31735;\n            for (i = 0; i < height; i++) {\n                row = bitmap[i] = new Uint8Array(width);\n                row1 = i < 1 ? row : bitmap[i - 1];\n                row2 = i < 2 ? row : bitmap[i - 2];\n                contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;\n                for (j = 0; j < width; j++) {\n                    row[j] = pixel = decoder.readBit(contexts, contextLabel);\n                    contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;\n                }\n            }\n            return bitmap;\n        }\n        function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {\n            if (mmr) {\n                error("JBIG2 error: MMR encoding is not supported");\n            }\n            if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {\n                return decodeBitmapTemplate0(width, height, decodingContext);\n            }\n            var useskip = !!skip;\n            var template = CodingTemplates[templateIndex].concat(at);\n            template.sort(function(a, b) {\n                return a.y - b.y || a.x - b.x;\n            });\n            var templateLength = template.length;\n            var templateX = new Int8Array(templateLength);\n            var templateY = new Int8Array(templateLength);\n            var changingTemplateEntries = [];\n            var reuseMask = 0, minX = 0, maxX = 0, minY = 0;\n            var c, k;\n            for (k = 0; k < templateLength; k++) {\n                templateX[k] = template[k].x;\n                templateY[k] = template[k].y;\n                minX = Math.min(minX, template[k].x);\n                maxX = Math.max(maxX, template[k].x);\n                minY = Math.min(minY, template[k].y);\n                if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {\n                    reuseMask |= 1 << templateLength - 1 - k;\n                } else {\n                    changingTemplateEntries.push(k);\n                }\n            }\n            var changingEntriesLength = changingTemplateEntries.length;\n            var changingTemplateX = new Int8Array(changingEntriesLength);\n            var changingTemplateY = new Int8Array(changingEntriesLength);\n            var changingTemplateBit = new Uint16Array(changingEntriesLength);\n            for (c = 0; c < changingEntriesLength; c++) {\n                k = changingTemplateEntries[c];\n                changingTemplateX[c] = template[k].x;\n                changingTemplateY[c] = template[k].y;\n                changingTemplateBit[c] = 1 << templateLength - 1 - k;\n            }\n            var sbb_left = -minX;\n            var sbb_top = -minY;\n            var sbb_right = width - maxX;\n            var pseudoPixelContext = ReusedContexts[templateIndex];\n            var row = new Uint8Array(width);\n            var bitmap = [];\n            var decoder = decodingContext.decoder;\n            var contexts = decodingContext.contextCache.getContexts("GB");\n            var ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;\n            for (var i = 0; i < height; i++) {\n                if (prediction) {\n                    var sltp = decoder.readBit(contexts, pseudoPixelContext);\n                    ltp ^= sltp;\n                    if (ltp) {\n                        bitmap.push(row);\n                        continue;\n                    }\n                }\n                row = new Uint8Array(row);\n                bitmap.push(row);\n                for (j = 0; j < width; j++) {\n                    if (useskip && skip[i][j]) {\n                        row[j] = 0;\n                        continue;\n                    }\n                    if (j >= sbb_left && j < sbb_right && i >= sbb_top) {\n                        contextLabel = contextLabel << 1 & reuseMask;\n                        for (k = 0; k < changingEntriesLength; k++) {\n                            i0 = i + changingTemplateY[k];\n                            j0 = j + changingTemplateX[k];\n                            bit = bitmap[i0][j0];\n                            if (bit) {\n                                bit = changingTemplateBit[k];\n                                contextLabel |= bit;\n                            }\n                        }\n                    } else {\n                        contextLabel = 0;\n                        shift = templateLength - 1;\n                        for (k = 0; k < templateLength; k++, shift--) {\n                            j0 = j + templateX[k];\n                            if (j0 >= 0 && j0 < width) {\n                                i0 = i + templateY[k];\n                                if (i0 >= 0) {\n                                    bit = bitmap[i0][j0];\n                                    if (bit) {\n                                        contextLabel |= bit << shift;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    var pixel = decoder.readBit(contexts, contextLabel);\n                    row[j] = pixel;\n                }\n            }\n            return bitmap;\n        }\n        function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {\n            var codingTemplate = RefinementTemplates[templateIndex].coding;\n            if (templateIndex === 0) {\n                codingTemplate = codingTemplate.concat([ at[0] ]);\n            }\n            var codingTemplateLength = codingTemplate.length;\n            var codingTemplateX = new Int32Array(codingTemplateLength);\n            var codingTemplateY = new Int32Array(codingTemplateLength);\n            var k;\n            for (k = 0; k < codingTemplateLength; k++) {\n                codingTemplateX[k] = codingTemplate[k].x;\n                codingTemplateY[k] = codingTemplate[k].y;\n            }\n            var referenceTemplate = RefinementTemplates[templateIndex].reference;\n            if (templateIndex === 0) {\n                referenceTemplate = referenceTemplate.concat([ at[1] ]);\n            }\n            var referenceTemplateLength = referenceTemplate.length;\n            var referenceTemplateX = new Int32Array(referenceTemplateLength);\n            var referenceTemplateY = new Int32Array(referenceTemplateLength);\n            for (k = 0; k < referenceTemplateLength; k++) {\n                referenceTemplateX[k] = referenceTemplate[k].x;\n                referenceTemplateY[k] = referenceTemplate[k].y;\n            }\n            var referenceWidth = referenceBitmap[0].length;\n            var referenceHeight = referenceBitmap.length;\n            var pseudoPixelContext = RefinementReusedContexts[templateIndex];\n            var bitmap = [];\n            var decoder = decodingContext.decoder;\n            var contexts = decodingContext.contextCache.getContexts("GR");\n            var ltp = 0;\n            for (var i = 0; i < height; i++) {\n                if (prediction) {\n                    var sltp = decoder.readBit(contexts, pseudoPixelContext);\n                    ltp ^= sltp;\n                    if (ltp) {\n                        error("JBIG2 error: prediction is not supported");\n                    }\n                }\n                var row = new Uint8Array(width);\n                bitmap.push(row);\n                for (var j = 0; j < width; j++) {\n                    var i0, j0;\n                    var contextLabel = 0;\n                    for (k = 0; k < codingTemplateLength; k++) {\n                        i0 = i + codingTemplateY[k];\n                        j0 = j + codingTemplateX[k];\n                        if (i0 < 0 || j0 < 0 || j0 >= width) {\n                            contextLabel <<= 1;\n                        } else {\n                            contextLabel = contextLabel << 1 | bitmap[i0][j0];\n                        }\n                    }\n                    for (k = 0; k < referenceTemplateLength; k++) {\n                        i0 = i + referenceTemplateY[k] + offsetY;\n                        j0 = j + referenceTemplateX[k] + offsetX;\n                        if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {\n                            contextLabel <<= 1;\n                        } else {\n                            contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];\n                        }\n                    }\n                    var pixel = decoder.readBit(contexts, contextLabel);\n                    row[j] = pixel;\n                }\n            }\n            return bitmap;\n        }\n        function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext) {\n            if (huffman) {\n                error("JBIG2 error: huffman is not supported");\n            }\n            var newSymbols = [];\n            var currentHeight = 0;\n            var symbolCodeLength = log2(symbols.length + numberOfNewSymbols);\n            var decoder = decodingContext.decoder;\n            var contextCache = decodingContext.contextCache;\n            while (newSymbols.length < numberOfNewSymbols) {\n                var deltaHeight = decodeInteger(contextCache, "IADH", decoder);\n                currentHeight += deltaHeight;\n                var currentWidth = 0;\n                var totalWidth = 0;\n                while (true) {\n                    var deltaWidth = decodeInteger(contextCache, "IADW", decoder);\n                    if (deltaWidth === null) {\n                        break;\n                    }\n                    currentWidth += deltaWidth;\n                    totalWidth += currentWidth;\n                    var bitmap;\n                    if (refinement) {\n                        var numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);\n                        if (numberOfInstances > 1) {\n                            bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext);\n                        } else {\n                            var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);\n                            var rdx = decodeInteger(contextCache, "IARDX", decoder);\n                            var rdy = decodeInteger(contextCache, "IARDY", decoder);\n                            var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];\n                            bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);\n                        }\n                    } else {\n                        bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);\n                    }\n                    newSymbols.push(bitmap);\n                }\n            }\n            var exportedSymbols = [];\n            var flags = [], currentFlag = false;\n            var totalSymbolsLength = symbols.length + numberOfNewSymbols;\n            while (flags.length < totalSymbolsLength) {\n                var runLength = decodeInteger(contextCache, "IAEX", decoder);\n                while (runLength--) {\n                    flags.push(currentFlag);\n                }\n                currentFlag = !currentFlag;\n            }\n            for (var i = 0, ii = symbols.length; i < ii; i++) {\n                if (flags[i]) {\n                    exportedSymbols.push(symbols[i]);\n                }\n            }\n            for (var j = 0; j < numberOfNewSymbols; i++, j++) {\n                if (flags[i]) {\n                    exportedSymbols.push(newSymbols[j]);\n                }\n            }\n            return exportedSymbols;\n        }\n        function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext) {\n            if (huffman) {\n                error("JBIG2 error: huffman is not supported");\n            }\n            var bitmap = [];\n            var i, row;\n            for (i = 0; i < height; i++) {\n                row = new Uint8Array(width);\n                if (defaultPixelValue) {\n                    for (var j = 0; j < width; j++) {\n                        row[j] = defaultPixelValue;\n                    }\n                }\n                bitmap.push(row);\n            }\n            var decoder = decodingContext.decoder;\n            var contextCache = decodingContext.contextCache;\n            var stripT = -decodeInteger(contextCache, "IADT", decoder);\n            var firstS = 0;\n            i = 0;\n            while (i < numberOfSymbolInstances) {\n                var deltaT = decodeInteger(contextCache, "IADT", decoder);\n                stripT += deltaT;\n                var deltaFirstS = decodeInteger(contextCache, "IAFS", decoder);\n                firstS += deltaFirstS;\n                var currentS = firstS;\n                do {\n                    var currentT = stripSize === 1 ? 0 : decodeInteger(contextCache, "IAIT", decoder);\n                    var t = stripSize * stripT + currentT;\n                    var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);\n                    var applyRefinement = refinement && decodeInteger(contextCache, "IARI", decoder);\n                    var symbolBitmap = inputSymbols[symbolId];\n                    var symbolWidth = symbolBitmap[0].length;\n                    var symbolHeight = symbolBitmap.length;\n                    if (applyRefinement) {\n                        var rdw = decodeInteger(contextCache, "IARDW", decoder);\n                        var rdh = decodeInteger(contextCache, "IARDH", decoder);\n                        var rdx = decodeInteger(contextCache, "IARDX", decoder);\n                        var rdy = decodeInteger(contextCache, "IARDY", decoder);\n                        symbolWidth += rdw;\n                        symbolHeight += rdh;\n                        symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);\n                    }\n                    var offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight);\n                    var offsetS = currentS - (referenceCorner & 2 ? symbolWidth : 0);\n                    var s2, t2, symbolRow;\n                    if (transposed) {\n                        for (s2 = 0; s2 < symbolHeight; s2++) {\n                            row = bitmap[offsetS + s2];\n                            if (!row) {\n                                continue;\n                            }\n                            symbolRow = symbolBitmap[s2];\n                            var maxWidth = Math.min(width - offsetT, symbolWidth);\n                            switch (combinationOperator) {\n                              case 0:\n                                for (t2 = 0; t2 < maxWidth; t2++) {\n                                    row[offsetT + t2] |= symbolRow[t2];\n                                }\n                                break;\n\n                              case 2:\n                                for (t2 = 0; t2 < maxWidth; t2++) {\n                                    row[offsetT + t2] ^= symbolRow[t2];\n                                }\n                                break;\n\n                              default:\n                                error("JBIG2 error: operator " + combinationOperator + " is not supported");\n                            }\n                        }\n                        currentS += symbolHeight - 1;\n                    } else {\n                        for (t2 = 0; t2 < symbolHeight; t2++) {\n                            row = bitmap[offsetT + t2];\n                            if (!row) {\n                                continue;\n                            }\n                            symbolRow = symbolBitmap[t2];\n                            switch (combinationOperator) {\n                              case 0:\n                                for (s2 = 0; s2 < symbolWidth; s2++) {\n                                    row[offsetS + s2] |= symbolRow[s2];\n                                }\n                                break;\n\n                              case 2:\n                                for (s2 = 0; s2 < symbolWidth; s2++) {\n                                    row[offsetS + s2] ^= symbolRow[s2];\n                                }\n                                break;\n\n                              default:\n                                error("JBIG2 error: operator " + combinationOperator + " is not supported");\n                            }\n                        }\n                        currentS += symbolWidth - 1;\n                    }\n                    i++;\n                    var deltaS = decodeInteger(contextCache, "IADS", decoder);\n                    if (deltaS === null) {\n                        break;\n                    }\n                    currentS += deltaS + dsOffset;\n                } while (true);\n            }\n            return bitmap;\n        }\n        function readSegmentHeader(data, start) {\n            var segmentHeader = {};\n            segmentHeader.number = readUint32(data, start);\n            var flags = data[start + 4];\n            var segmentType = flags & 63;\n            if (!SegmentTypes[segmentType]) {\n                error("JBIG2 error: invalid segment type: " + segmentType);\n            }\n            segmentHeader.type = segmentType;\n            segmentHeader.typeName = SegmentTypes[segmentType];\n            segmentHeader.deferredNonRetain = !!(flags & 128);\n            var pageAssociationFieldSize = !!(flags & 64);\n            var referredFlags = data[start + 5];\n            var referredToCount = referredFlags >> 5 & 7;\n            var retainBits = [ referredFlags & 31 ];\n            var position = start + 6;\n            if (referredFlags === 7) {\n                referredToCount = readUint32(data, position - 1) & 536870911;\n                position += 3;\n                var bytes = referredToCount + 7 >> 3;\n                retainBits[0] = data[position++];\n                while (--bytes > 0) {\n                    retainBits.push(data[position++]);\n                }\n            } else if (referredFlags === 5 || referredFlags === 6) {\n                error("JBIG2 error: invalid referred-to flags");\n            }\n            segmentHeader.retainBits = retainBits;\n            var referredToSegmentNumberSize = segmentHeader.number <= 256 ? 1 : segmentHeader.number <= 65536 ? 2 : 4;\n            var referredTo = [];\n            var i, ii;\n            for (i = 0; i < referredToCount; i++) {\n                var number = referredToSegmentNumberSize === 1 ? data[position] : referredToSegmentNumberSize === 2 ? readUint16(data, position) : readUint32(data, position);\n                referredTo.push(number);\n                position += referredToSegmentNumberSize;\n            }\n            segmentHeader.referredTo = referredTo;\n            if (!pageAssociationFieldSize) {\n                segmentHeader.pageAssociation = data[position++];\n            } else {\n                segmentHeader.pageAssociation = readUint32(data, position);\n                position += 4;\n            }\n            segmentHeader.length = readUint32(data, position);\n            position += 4;\n            if (segmentHeader.length === 4294967295) {\n                if (segmentType === 38) {\n                    var genericRegionInfo = readRegionSegmentInformation(data, position);\n                    var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];\n                    var genericRegionMmr = !!(genericRegionSegmentFlags & 1);\n                    var searchPatternLength = 6;\n                    var searchPattern = new Uint8Array(searchPatternLength);\n                    if (!genericRegionMmr) {\n                        searchPattern[0] = 255;\n                        searchPattern[1] = 172;\n                    }\n                    searchPattern[2] = genericRegionInfo.height >>> 24 & 255;\n                    searchPattern[3] = genericRegionInfo.height >> 16 & 255;\n                    searchPattern[4] = genericRegionInfo.height >> 8 & 255;\n                    searchPattern[5] = genericRegionInfo.height & 255;\n                    for (i = position, ii = data.length; i < ii; i++) {\n                        var j = 0;\n                        while (j < searchPatternLength && searchPattern[j] === data[i + j]) {\n                            j++;\n                        }\n                        if (j === searchPatternLength) {\n                            segmentHeader.length = i + searchPatternLength;\n                            break;\n                        }\n                    }\n                    if (segmentHeader.length === 4294967295) {\n                        error("JBIG2 error: segment end was not found");\n                    }\n                } else {\n                    error("JBIG2 error: invalid unknown segment length");\n                }\n            }\n            segmentHeader.headerEnd = position;\n            return segmentHeader;\n        }\n        function readSegments(header, data, start, end) {\n            var segments = [];\n            var position = start;\n            while (position < end) {\n                var segmentHeader = readSegmentHeader(data, position);\n                position = segmentHeader.headerEnd;\n                var segment = {\n                    header: segmentHeader,\n                    data: data\n                };\n                if (!header.randomAccess) {\n                    segment.start = position;\n                    position += segmentHeader.length;\n                    segment.end = position;\n                }\n                segments.push(segment);\n                if (segmentHeader.type === 51) {\n                    break;\n                }\n            }\n            if (header.randomAccess) {\n                for (var i = 0, ii = segments.length; i < ii; i++) {\n                    segments[i].start = position;\n                    position += segments[i].header.length;\n                    segments[i].end = position;\n                }\n            }\n            return segments;\n        }\n        function readRegionSegmentInformation(data, start) {\n            return {\n                width: readUint32(data, start),\n                height: readUint32(data, start + 4),\n                x: readUint32(data, start + 8),\n                y: readUint32(data, start + 12),\n                combinationOperator: data[start + 16] & 7\n            };\n        }\n        var RegionSegmentInformationFieldLength = 17;\n        function processSegment(segment, visitor) {\n            var header = segment.header;\n            var data = segment.data, position = segment.start, end = segment.end;\n            var args, at, i, atLength;\n            switch (header.type) {\n              case 0:\n                var dictionary = {};\n                var dictionaryFlags = readUint16(data, position);\n                dictionary.huffman = !!(dictionaryFlags & 1);\n                dictionary.refinement = !!(dictionaryFlags & 2);\n                dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;\n                dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;\n                dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;\n                dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;\n                dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);\n                dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);\n                dictionary.template = dictionaryFlags >> 10 & 3;\n                dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;\n                position += 2;\n                if (!dictionary.huffman) {\n                    atLength = dictionary.template === 0 ? 4 : 1;\n                    at = [];\n                    for (i = 0; i < atLength; i++) {\n                        at.push({\n                            x: readInt8(data, position),\n                            y: readInt8(data, position + 1)\n                        });\n                        position += 2;\n                    }\n                    dictionary.at = at;\n                }\n                if (dictionary.refinement && !dictionary.refinementTemplate) {\n                    at = [];\n                    for (i = 0; i < 2; i++) {\n                        at.push({\n                            x: readInt8(data, position),\n                            y: readInt8(data, position + 1)\n                        });\n                        position += 2;\n                    }\n                    dictionary.refinementAt = at;\n                }\n                dictionary.numberOfExportedSymbols = readUint32(data, position);\n                position += 4;\n                dictionary.numberOfNewSymbols = readUint32(data, position);\n                position += 4;\n                args = [ dictionary, header.number, header.referredTo, data, position, end ];\n                break;\n\n              case 6:\n              case 7:\n                var textRegion = {};\n                textRegion.info = readRegionSegmentInformation(data, position);\n                position += RegionSegmentInformationFieldLength;\n                var textRegionSegmentFlags = readUint16(data, position);\n                position += 2;\n                textRegion.huffman = !!(textRegionSegmentFlags & 1);\n                textRegion.refinement = !!(textRegionSegmentFlags & 2);\n                textRegion.stripSize = 1 << (textRegionSegmentFlags >> 2 & 3);\n                textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;\n                textRegion.transposed = !!(textRegionSegmentFlags & 64);\n                textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;\n                textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;\n                textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;\n                textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;\n                if (textRegion.huffman) {\n                    var textRegionHuffmanFlags = readUint16(data, position);\n                    position += 2;\n                    textRegion.huffmanFS = textRegionHuffmanFlags & 3;\n                    textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;\n                    textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;\n                    textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;\n                    textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;\n                    textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;\n                    textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;\n                    textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 14);\n                }\n                if (textRegion.refinement && !textRegion.refinementTemplate) {\n                    at = [];\n                    for (i = 0; i < 2; i++) {\n                        at.push({\n                            x: readInt8(data, position),\n                            y: readInt8(data, position + 1)\n                        });\n                        position += 2;\n                    }\n                    textRegion.refinementAt = at;\n                }\n                textRegion.numberOfSymbolInstances = readUint32(data, position);\n                position += 4;\n                if (textRegion.huffman) {\n                    error("JBIG2 error: huffman is not supported");\n                }\n                args = [ textRegion, header.referredTo, data, position, end ];\n                break;\n\n              case 38:\n              case 39:\n                var genericRegion = {};\n                genericRegion.info = readRegionSegmentInformation(data, position);\n                position += RegionSegmentInformationFieldLength;\n                var genericRegionSegmentFlags = data[position++];\n                genericRegion.mmr = !!(genericRegionSegmentFlags & 1);\n                genericRegion.template = genericRegionSegmentFlags >> 1 & 3;\n                genericRegion.prediction = !!(genericRegionSegmentFlags & 8);\n                if (!genericRegion.mmr) {\n                    atLength = genericRegion.template === 0 ? 4 : 1;\n                    at = [];\n                    for (i = 0; i < atLength; i++) {\n                        at.push({\n                            x: readInt8(data, position),\n                            y: readInt8(data, position + 1)\n                        });\n                        position += 2;\n                    }\n                    genericRegion.at = at;\n                }\n                args = [ genericRegion, data, position, end ];\n                break;\n\n              case 48:\n                var pageInfo = {\n                    width: readUint32(data, position),\n                    height: readUint32(data, position + 4),\n                    resolutionX: readUint32(data, position + 8),\n                    resolutionY: readUint32(data, position + 12)\n                };\n                if (pageInfo.height === 4294967295) {\n                    delete pageInfo.height;\n                }\n                var pageSegmentFlags = data[position + 16];\n                var pageStripingInformatiom = readUint16(data, position + 17);\n                pageInfo.lossless = !!(pageSegmentFlags & 1);\n                pageInfo.refinement = !!(pageSegmentFlags & 2);\n                pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;\n                pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;\n                pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);\n                pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);\n                args = [ pageInfo ];\n                break;\n\n              case 49:\n                break;\n\n              case 50:\n                break;\n\n              case 51:\n                break;\n\n              case 62:\n                break;\n\n              default:\n                error("JBIG2 error: segment type " + header.typeName + "(" + header.type + ") is not implemented");\n            }\n            var callbackName = "on" + header.typeName;\n            if (callbackName in visitor) {\n                visitor[callbackName].apply(visitor, args);\n            }\n        }\n        function processSegments(segments, visitor) {\n            for (var i = 0, ii = segments.length; i < ii; i++) {\n                processSegment(segments[i], visitor);\n            }\n        }\n        function parseJbig2(data, start, end) {\n            var position = start;\n            if (data[position] !== 151 || data[position + 1] !== 74 || data[position + 2] !== 66 || data[position + 3] !== 50 || data[position + 4] !== 13 || data[position + 5] !== 10 || data[position + 6] !== 26 || data[position + 7] !== 10) {\n                error("JBIG2 error: invalid header");\n            }\n            var header = {};\n            position += 8;\n            var flags = data[position++];\n            header.randomAccess = !(flags & 1);\n            if (!(flags & 2)) {\n                header.numberOfPages = readUint32(data, position);\n                position += 4;\n            }\n            var segments = readSegments(header, data, position, end);\n            error("Not implemented");\n        }\n        function parseJbig2Chunks(chunks) {\n            var visitor = new SimpleSegmentVisitor();\n            for (var i = 0, ii = chunks.length; i < ii; i++) {\n                var chunk = chunks[i];\n                var segments = readSegments({}, chunk.data, chunk.start, chunk.end);\n                processSegments(segments, visitor);\n            }\n            return visitor;\n        }\n        function SimpleSegmentVisitor() {}\n        SimpleSegmentVisitor.prototype = {\n            onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {\n                this.currentPageInfo = info;\n                var rowSize = info.width + 7 >> 3;\n                var buffer = new Uint8Array(rowSize * info.height);\n                if (info.defaultPixelValue) {\n                    for (var i = 0, ii = buffer.length; i < ii; i++) {\n                        buffer[i] = 255;\n                    }\n                }\n                this.buffer = buffer;\n            },\n            drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {\n                var pageInfo = this.currentPageInfo;\n                var width = regionInfo.width, height = regionInfo.height;\n                var rowSize = pageInfo.width + 7 >> 3;\n                var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;\n                var buffer = this.buffer;\n                var mask0 = 128 >> (regionInfo.x & 7);\n                var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);\n                var i, j, mask, offset;\n                switch (combinationOperator) {\n                  case 0:\n                    for (i = 0; i < height; i++) {\n                        mask = mask0;\n                        offset = offset0;\n                        for (j = 0; j < width; j++) {\n                            if (bitmap[i][j]) {\n                                buffer[offset] |= mask;\n                            }\n                            mask >>= 1;\n                            if (!mask) {\n                                mask = 128;\n                                offset++;\n                            }\n                        }\n                        offset0 += rowSize;\n                    }\n                    break;\n\n                  case 2:\n                    for (i = 0; i < height; i++) {\n                        mask = mask0;\n                        offset = offset0;\n                        for (j = 0; j < width; j++) {\n                            if (bitmap[i][j]) {\n                                buffer[offset] ^= mask;\n                            }\n                            mask >>= 1;\n                            if (!mask) {\n                                mask = 128;\n                                offset++;\n                            }\n                        }\n                        offset0 += rowSize;\n                    }\n                    break;\n\n                  default:\n                    error("JBIG2 error: operator " + combinationOperator + " is not supported");\n                }\n            },\n            onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {\n                var regionInfo = region.info;\n                var decodingContext = new DecodingContext(data, start, end);\n                var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);\n                this.drawBitmap(regionInfo, bitmap);\n            },\n            onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {\n                this.onImmediateGenericRegion.apply(this, arguments);\n            },\n            onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {\n                var huffmanTables;\n                if (dictionary.huffman) {\n                    error("JBIG2 error: huffman is not supported");\n                }\n                var symbols = this.symbols;\n                if (!symbols) {\n                    this.symbols = symbols = {};\n                }\n                var inputSymbols = [];\n                for (var i = 0, ii = referredSegments.length; i < ii; i++) {\n                    inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);\n                }\n                var decodingContext = new DecodingContext(data, start, end);\n                symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext);\n            },\n            onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {\n                var regionInfo = region.info;\n                var huffmanTables;\n                var symbols = this.symbols;\n                var inputSymbols = [];\n                for (var i = 0, ii = referredSegments.length; i < ii; i++) {\n                    inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);\n                }\n                var symbolCodeLength = log2(inputSymbols.length);\n                var decodingContext = new DecodingContext(data, start, end);\n                var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext);\n                this.drawBitmap(regionInfo, bitmap);\n            },\n            onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {\n                this.onImmediateTextRegion.apply(this, arguments);\n            }\n        };\n        function Jbig2Image() {}\n        Jbig2Image.prototype = {\n            parseChunks: function Jbig2Image_parseChunks(chunks) {\n                return parseJbig2Chunks(chunks);\n            }\n        };\n        return Jbig2Image;\n    }();\n    function log2(x) {\n        var n = 1, i = 0;\n        while (x > n) {\n            n <<= 1;\n            i++;\n        }\n        return i;\n    }\n    function readInt8(data, start) {\n        return data[start] << 24 >> 24;\n    }\n    function readUint16(data, offset) {\n        return data[offset] << 8 | data[offset + 1];\n    }\n    function readUint32(data, offset) {\n        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\n    }\n    function shadow(obj, prop, value) {\n        Object.defineProperty(obj, prop, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: false\n        });\n        return value;\n    }\n    var error = function() {\n        console.error.apply(console, arguments);\n        throw new Error("PDFJS error: " + arguments[0]);\n    };\n    var warn = function() {\n        console.warn.apply(console, arguments);\n    };\n    var info = function() {\n        console.info.apply(console, arguments);\n    };\n    Jbig2Image.prototype.parse = function parseJbig2(data) {\n        var position = 0, end = data.length;\n        if (data[position] !== 151 || data[position + 1] !== 74 || data[position + 2] !== 66 || data[position + 3] !== 50 || data[position + 4] !== 13 || data[position + 5] !== 10 || data[position + 6] !== 26 || data[position + 7] !== 10) {\n            error("JBIG2 error: invalid header");\n        }\n        var header = {};\n        position += 8;\n        var flags = data[position++];\n        header.randomAccess = !(flags & 1);\n        if (!(flags & 2)) {\n            header.numberOfPages = readUint32(data, position);\n            position += 4;\n        }\n        var visitor = this.parseChunks([ {\n            data: data,\n            start: position,\n            end: end\n        } ]);\n        var width = visitor.currentPageInfo.width;\n        var height = visitor.currentPageInfo.height;\n        var bitPacked = visitor.buffer;\n        var data = new Uint8Array(width * height);\n        var q = 0, k = 0;\n        for (var i = 0; i < height; i++) {\n            var mask = 0, buffer;\n            for (var j = 0; j < width; j++) {\n                if (!mask) {\n                    mask = 128;\n                    buffer = bitPacked[k++];\n                }\n                data[q++] = buffer & mask ? 0 : 255;\n                mask >>= 1;\n            }\n        }\n        this.width = width;\n        this.height = height;\n        this.data = data;\n    };\n    PDFJS.JpegImage = JpegImage;\n    PDFJS.JpxImage = JpxImage;\n    PDFJS.Jbig2Image = Jbig2Image;\n})(PDFJS || (PDFJS = {}));\n\nvar JpegDecoder = PDFJS.JpegImage;\n\nvar JpxDecoder = PDFJS.JpxImage;\n\nvar Jbig2Decoder = PDFJS.Jbig2Image;;\n\n// Make png.js & config.js worker compatible\nvar document = {\n    createElement: function() { return { getContext: function() {} } }\n};\nvar window = {};\n\n// Import png.js\n/*\n * Extracted from pdf.js\n * https://github.com/andreasgal/pdf.js\n *\n * Copyright (c) 2011 Mozilla Foundation\n *\n * Contributors: Andreas Gal <gal@mozilla.com>\n *               Chris G Jones <cjones@mozilla.com>\n *               Shaon Barman <shaon.barman@gmail.com>\n *               Vivien Nicolas <21@vingtetun.org>\n *               Justin D\'Arcangelo <justindarc@gmail.com>\n *               Yury Delendik\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the "Software"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nvar DecodeStream = (function() {\n  function constructor() {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = null;\n  }\n\n  constructor.prototype = {\n    ensureBuffer: function decodestream_ensureBuffer(requested) {\n      var buffer = this.buffer;\n      var current = buffer ? buffer.byteLength : 0;\n      if (requested < current)\n        return buffer;\n      var size = 512;\n      while (size < requested)\n        size <<= 1;\n      var buffer2 = new Uint8Array(size);\n      for (var i = 0; i < current; ++i)\n        buffer2[i] = buffer[i];\n      return this.buffer = buffer2;\n    },\n    getByte: function decodestream_getByte() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return this.buffer[this.pos++];\n    },\n    getBytes: function decodestream_getBytes(length) {\n      var pos = this.pos;\n\n      if (length) {\n        this.ensureBuffer(pos + length);\n        var end = pos + length;\n\n        while (!this.eof && this.bufferLength < end)\n          this.readBlock();\n\n        var bufEnd = this.bufferLength;\n        if (end > bufEnd)\n          end = bufEnd;\n      } else {\n        while (!this.eof)\n          this.readBlock();\n\n        var end = this.bufferLength;\n      }\n\n      this.pos = end;\n      return this.buffer.subarray(pos, end);\n    },\n    lookChar: function decodestream_lookChar() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return String.fromCharCode(this.buffer[this.pos]);\n    },\n    getChar: function decodestream_getChar() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return String.fromCharCode(this.buffer[this.pos++]);\n    },\n    makeSubStream: function decodestream_makeSubstream(start, length, dict) {\n      var end = start + length;\n      while (this.bufferLength <= end && !this.eof)\n        this.readBlock();\n      return new Stream(this.buffer, start, length, dict);\n    },\n    skip: function decodestream_skip(n) {\n      if (!n)\n        n = 1;\n      this.pos += n;\n    },\n    reset: function decodestream_reset() {\n      this.pos = 0;\n    }\n  };\n\n  return constructor;\n})();\n\nvar FlateStream = (function() {\n  var codeLenCodeMap = new Uint32Array([\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n  ]);\n\n  var lengthDecode = new Uint32Array([\n    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,\n    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,\n    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,\n    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102\n  ]);\n\n  var distDecode = new Uint32Array([\n    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,\n    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,\n    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,\n    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001\n  ]);\n\n  var fixedLitCodeTab = [new Uint32Array([\n    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,\n    0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,\n    0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,\n    0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,\n    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,\n    0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,\n    0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,\n    0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,\n    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,\n    0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,\n    0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,\n    0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,\n    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,\n    0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,\n    0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,\n    0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,\n    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,\n    0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,\n    0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,\n    0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,\n    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,\n    0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,\n    0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,\n    0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,\n    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,\n    0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,\n    0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,\n    0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,\n    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,\n    0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,\n    0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,\n    0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,\n    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,\n    0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,\n    0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,\n    0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,\n    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,\n    0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,\n    0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,\n    0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,\n    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,\n    0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,\n    0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,\n    0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,\n    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,\n    0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,\n    0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,\n    0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,\n    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,\n    0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,\n    0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,\n    0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,\n    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,\n    0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,\n    0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,\n    0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,\n    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,\n    0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,\n    0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,\n    0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,\n    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,\n    0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,\n    0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,\n    0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff\n  ]), 9];\n\n  var fixedDistCodeTab = [new Uint32Array([\n    0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,\n    0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,\n    0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,\n    0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000\n  ]), 5];\n  \n  function error(e) {\n      throw new Error(e)\n  }\n\n  function constructor(bytes) {\n    //var bytes = stream.getBytes();\n    var bytesPos = 0;\n\n    var cmf = bytes[bytesPos++];\n    var flg = bytes[bytesPos++];\n    if (cmf == -1 || flg == -1)\n      error(\'Invalid header in flate stream\');\n    if ((cmf & 0x0f) != 0x08)\n      error(\'Unknown compression method in flate stream\');\n    if ((((cmf << 8) + flg) % 31) != 0)\n      error(\'Bad FCHECK in flate stream\');\n    if (flg & 0x20)\n      error(\'FDICT bit set in flate stream\');\n\n    this.bytes = bytes;\n    this.bytesPos = bytesPos;\n\n    this.codeSize = 0;\n    this.codeBuf = 0;\n\n    DecodeStream.call(this);\n  }\n\n  constructor.prototype = Object.create(DecodeStream.prototype);\n\n  constructor.prototype.getBits = function(bits) {\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n\n    var b;\n    while (codeSize < bits) {\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad encoding in flate stream\');\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n    b = codeBuf & ((1 << bits) - 1);\n    this.codeBuf = codeBuf >> bits;\n    this.codeSize = codeSize -= bits;\n    this.bytesPos = bytesPos;\n    return b;\n  };\n\n  constructor.prototype.getCode = function(table) {\n    var codes = table[0];\n    var maxLen = table[1];\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n\n    while (codeSize < maxLen) {\n      var b;\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad encoding in flate stream\');\n      codeBuf |= (b << codeSize);\n      codeSize += 8;\n    }\n    var code = codes[codeBuf & ((1 << maxLen) - 1)];\n    var codeLen = code >> 16;\n    var codeVal = code & 0xffff;\n    if (codeSize == 0 || codeSize < codeLen || codeLen == 0)\n      error(\'Bad encoding in flate stream\');\n    this.codeBuf = (codeBuf >> codeLen);\n    this.codeSize = (codeSize - codeLen);\n    this.bytesPos = bytesPos;\n    return codeVal;\n  };\n\n  constructor.prototype.generateHuffmanTable = function(lengths) {\n    var n = lengths.length;\n\n    // find max code length\n    var maxLen = 0;\n    for (var i = 0; i < n; ++i) {\n      if (lengths[i] > maxLen)\n        maxLen = lengths[i];\n    }\n\n    // build the table\n    var size = 1 << maxLen;\n    var codes = new Uint32Array(size);\n    for (var len = 1, code = 0, skip = 2;\n         len <= maxLen;\n         ++len, code <<= 1, skip <<= 1) {\n      for (var val = 0; val < n; ++val) {\n        if (lengths[val] == len) {\n          // bit-reverse the code\n          var code2 = 0;\n          var t = code;\n          for (var i = 0; i < len; ++i) {\n            code2 = (code2 << 1) | (t & 1);\n            t >>= 1;\n          }\n\n          // fill the table entries\n          for (var i = code2; i < size; i += skip)\n            codes[i] = (len << 16) | val;\n\n          ++code;\n        }\n      }\n    }\n\n    return [codes, maxLen];\n  };\n\n  constructor.prototype.readBlock = function() {\n    function repeat(stream, array, len, offset, what) {\n      var repeat = stream.getBits(len) + offset;\n      while (repeat-- > 0)\n        array[i++] = what;\n    }\n\n    // read block header\n    var hdr = this.getBits(3);\n    if (hdr & 1)\n      this.eof = true;\n    hdr >>= 1;\n\n    if (hdr == 0) { // uncompressed block\n      var bytes = this.bytes;\n      var bytesPos = this.bytesPos;\n      var b;\n\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad block header in flate stream\');\n      var blockLen = b;\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad block header in flate stream\');\n      blockLen |= (b << 8);\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad block header in flate stream\');\n      var check = b;\n      if (typeof (b = bytes[bytesPos++]) == \'undefined\')\n        error(\'Bad block header in flate stream\');\n      check |= (b << 8);\n      if (check != (~blockLen & 0xffff))\n        error(\'Bad uncompressed block length in flate stream\');\n\n      this.codeBuf = 0;\n      this.codeSize = 0;\n\n      var bufferLength = this.bufferLength;\n      var buffer = this.ensureBuffer(bufferLength + blockLen);\n      var end = bufferLength + blockLen;\n      this.bufferLength = end;\n      for (var n = bufferLength; n < end; ++n) {\n        if (typeof (b = bytes[bytesPos++]) == \'undefined\') {\n          this.eof = true;\n          break;\n        }\n        buffer[n] = b;\n      }\n      this.bytesPos = bytesPos;\n      return;\n    }\n\n    var litCodeTable;\n    var distCodeTable;\n    if (hdr == 1) { // compressed block, fixed codes\n      litCodeTable = fixedLitCodeTab;\n      distCodeTable = fixedDistCodeTab;\n    } else if (hdr == 2) { // compressed block, dynamic codes\n      var numLitCodes = this.getBits(5) + 257;\n      var numDistCodes = this.getBits(5) + 1;\n      var numCodeLenCodes = this.getBits(4) + 4;\n\n      // build the code lengths code table\n      var codeLenCodeLengths = Array(codeLenCodeMap.length);\n      var i = 0;\n      while (i < numCodeLenCodes)\n        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);\n      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);\n\n      // build the literal and distance code tables\n      var len = 0;\n      var i = 0;\n      var codes = numLitCodes + numDistCodes;\n      var codeLengths = new Array(codes);\n      while (i < codes) {\n        var code = this.getCode(codeLenCodeTab);\n        if (code == 16) {\n          repeat(this, codeLengths, 2, 3, len);\n        } else if (code == 17) {\n          repeat(this, codeLengths, 3, 3, len = 0);\n        } else if (code == 18) {\n          repeat(this, codeLengths, 7, 11, len = 0);\n        } else {\n          codeLengths[i++] = len = code;\n        }\n      }\n\n      litCodeTable =\n        this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));\n      distCodeTable =\n        this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));\n    } else {\n      error(\'Unknown block type in flate stream\');\n    }\n\n    var buffer = this.buffer;\n    var limit = buffer ? buffer.length : 0;\n    var pos = this.bufferLength;\n    while (true) {\n      var code1 = this.getCode(litCodeTable);\n      if (code1 < 256) {\n        if (pos + 1 >= limit) {\n          buffer = this.ensureBuffer(pos + 1);\n          limit = buffer.length;\n        }\n        buffer[pos++] = code1;\n        continue;\n      }\n      if (code1 == 256) {\n        this.bufferLength = pos;\n        return;\n      }\n      code1 -= 257;\n      code1 = lengthDecode[code1];\n      var code2 = code1 >> 16;\n      if (code2 > 0)\n        code2 = this.getBits(code2);\n      var len = (code1 & 0xffff) + code2;\n      code1 = this.getCode(distCodeTable);\n      code1 = distDecode[code1];\n      code2 = code1 >> 16;\n      if (code2 > 0)\n        code2 = this.getBits(code2);\n      var dist = (code1 & 0xffff) + code2;\n      if (pos + len >= limit) {\n        buffer = this.ensureBuffer(pos + len);\n        limit = buffer.length;\n      }\n      for (var k = 0; k < len; ++k, ++pos)\n        buffer[pos] = buffer[pos - dist];\n    }\n  };\n\n  return constructor;\n})();; // @todo in build mode\n// Generated by CoffeeScript 1.4.0\n\n/*\n# MIT LICENSE\n# Copyright (c) 2011 Devon Govett\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy of this \n# software and associated documentation files (the "Software"), to deal in the Software \n# without restriction, including without limitation the rights to use, copy, modify, merge, \n# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons \n# to whom the Software is furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in all copies or \n# substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING \n# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n(function() {\n  var PNG;\n\n  PNG = (function() {\n    var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;\n\n    PNG.load = function(url, canvas, callback) {\n      var xhr,\n        _this = this;\n      if (typeof canvas === \'function\') {\n        callback = canvas;\n      }\n      xhr = new XMLHttpRequest;\n      xhr.open("GET", url, true);\n      xhr.responseType = "arraybuffer";\n      xhr.onload = function() {\n        var data, png;\n        data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        png = new PNG(data);\n        if (typeof (canvas != null ? canvas.getContext : void 0) === \'function\') {\n          png.render(canvas);\n        }\n        return typeof callback === "function" ? callback(png) : void 0;\n      };\n      return xhr.send(null);\n    };\n\n    APNG_DISPOSE_OP_NONE = 0;\n\n    APNG_DISPOSE_OP_BACKGROUND = 1;\n\n    APNG_DISPOSE_OP_PREVIOUS = 2;\n\n    APNG_BLEND_OP_SOURCE = 0;\n\n    APNG_BLEND_OP_OVER = 1;\n\n    function PNG(data) {\n      var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, short, text, _i, _j, _ref;\n      this.data = data;\n      this.pos = 8;\n      this.palette = [];\n      this.imgData = [];\n      this.transparency = {};\n      this.animation = null;\n      this.text = {};\n      frame = null;\n      while (true) {\n        chunkSize = this.readUInt32();\n        section = ((function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; _i < 4; i = ++_i) {\n            _results.push(String.fromCharCode(this.data[this.pos++]));\n          }\n          return _results;\n        }).call(this)).join(\'\');\n        switch (section) {\n          case \'IHDR\':\n            this.width = this.readUInt32();\n            this.height = this.readUInt32();\n            this.bits = this.data[this.pos++];\n            this.colorType = this.data[this.pos++];\n            this.compressionMethod = this.data[this.pos++];\n            this.filterMethod = this.data[this.pos++];\n            this.interlaceMethod = this.data[this.pos++];\n            break;\n          case \'acTL\':\n            this.animation = {\n              numFrames: this.readUInt32(),\n              numPlays: this.readUInt32() || Infinity,\n              frames: []\n            };\n            break;\n          case \'PLTE\':\n            this.palette = this.read(chunkSize);\n            break;\n          case \'fcTL\':\n            if (frame) {\n              this.animation.frames.push(frame);\n            }\n            this.pos += 4;\n            frame = {\n              width: this.readUInt32(),\n              height: this.readUInt32(),\n              xOffset: this.readUInt32(),\n              yOffset: this.readUInt32()\n            };\n            delayNum = this.readUInt16();\n            delayDen = this.readUInt16() || 100;\n            frame.delay = 1000 * delayNum / delayDen;\n            frame.disposeOp = this.data[this.pos++];\n            frame.blendOp = this.data[this.pos++];\n            frame.data = [];\n            break;\n          case \'IDAT\':\n          case \'fdAT\':\n            if (section === \'fdAT\') {\n              this.pos += 4;\n              chunkSize -= 4;\n            }\n            data = (frame != null ? frame.data : void 0) || this.imgData;\n            for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {\n              data.push(this.data[this.pos++]);\n            }\n            break;\n          case \'tRNS\':\n            this.transparency = {};\n            switch (this.colorType) {\n              case 3:\n                this.transparency.indexed = this.read(chunkSize);\n                short = 255 - this.transparency.indexed.length;\n                if (short > 0) {\n                  for (i = _j = 0; 0 <= short ? _j < short : _j > short; i = 0 <= short ? ++_j : --_j) {\n                    this.transparency.indexed.push(255);\n                  }\n                }\n                break;\n              case 0:\n                this.transparency.grayscale = this.read(chunkSize)[0];\n                break;\n              case 2:\n                this.transparency.rgb = this.read(chunkSize);\n            }\n            break;\n          case \'tEXt\':\n            text = this.read(chunkSize);\n            index = text.indexOf(0);\n            key = String.fromCharCode.apply(String, text.slice(0, index));\n            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n            break;\n          case \'IEND\':\n            if (frame) {\n              this.animation.frames.push(frame);\n            }\n            this.colors = (function() {\n              switch (this.colorType) {\n                case 0:\n                case 3:\n                case 4:\n                  return 1;\n                case 2:\n                case 6:\n                  return 3;\n              }\n            }).call(this);\n            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;\n            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n            this.pixelBitlength = this.bits * colors;\n            this.colorSpace = (function() {\n              switch (this.colors) {\n                case 1:\n                  return \'DeviceGray\';\n                case 3:\n                  return \'DeviceRGB\';\n              }\n            }).call(this);\n            this.imgData = new Uint8Array(this.imgData);\n            return;\n          default:\n            this.pos += chunkSize;\n        }\n        this.pos += 4;\n        if (this.pos > this.data.length) {\n          throw new Error("Incomplete or corrupt PNG file");\n        }\n      }\n      return;\n    }\n\n    PNG.prototype.read = function(bytes) {\n      var i, _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {\n        _results.push(this.data[this.pos++]);\n      }\n      return _results;\n    };\n\n    PNG.prototype.readUInt32 = function() {\n      var b1, b2, b3, b4;\n      b1 = this.data[this.pos++] << 24;\n      b2 = this.data[this.pos++] << 16;\n      b3 = this.data[this.pos++] << 8;\n      b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    };\n\n    PNG.prototype.readUInt16 = function() {\n      var b1, b2;\n      b1 = this.data[this.pos++] << 8;\n      b2 = this.data[this.pos++];\n      return b1 | b2;\n    };\n\n    PNG.prototype.decodePixels = function(data) {\n      var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;\n      if (data == null) {\n        data = this.imgData;\n      }\n      if (data.length === 0) {\n        return new Uint8Array(0);\n      }\n      data = new FlateStream(data);\n      data = data.getBytes();\n      pixelBytes = this.pixelBitlength / 8;\n      scanlineLength = pixelBytes * this.width;\n      pixels = new Uint8Array(scanlineLength * this.height);\n      length = data.length;\n      row = 0;\n      pos = 0;\n      c = 0;\n      while (pos < length) {\n        switch (data[pos++]) {\n          case 0:\n            for (i = _i = 0; _i < scanlineLength; i = _i += 1) {\n              pixels[c++] = data[pos++];\n            }\n            break;\n          case 1:\n            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {\n              byte = data[pos++];\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              pixels[c++] = (byte + left) % 256;\n            }\n            break;\n          case 2:\n            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {\n              byte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n              pixels[c++] = (upper + byte) % 256;\n            }\n            break;\n          case 3:\n            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {\n              byte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n              pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n            }\n            break;\n          case 4:\n            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {\n              byte = data[pos++];\n              col = (i - (i % pixelBytes)) / pixelBytes;\n              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n              if (row === 0) {\n                upper = upperLeft = 0;\n              } else {\n                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];\n              }\n              p = left + upper - upperLeft;\n              pa = Math.abs(p - left);\n              pb = Math.abs(p - upper);\n              pc = Math.abs(p - upperLeft);\n              if (pa <= pb && pa <= pc) {\n                paeth = left;\n              } else if (pb <= pc) {\n                paeth = upper;\n              } else {\n                paeth = upperLeft;\n              }\n              pixels[c++] = (byte + paeth) % 256;\n            }\n            break;\n          default:\n            throw new Error("Invalid filter algorithm: " + data[pos - 1]);\n        }\n        row++;\n      }\n      return pixels;\n    };\n\n    PNG.prototype.decodePalette = function() {\n      var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;\n      palette = this.palette;\n      transparency = this.transparency.indexed || [];\n      ret = new Uint8Array((transparency.length || 0) + palette.length);\n      pos = 0;\n      length = palette.length;\n      c = 0;\n      for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {\n        ret[pos++] = palette[i];\n        ret[pos++] = palette[i + 1];\n        ret[pos++] = palette[i + 2];\n        ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;\n      }\n      return ret;\n    };\n\n    PNG.prototype.copyToImageData = function(imageData, pixels) {\n      var alpha, colors, data, i, input, j, k, length, palette, v, _ref;\n      colors = this.colors;\n      palette = null;\n      alpha = this.hasAlphaChannel;\n      if (this.palette.length) {\n        palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n      data = imageData.data || imageData;\n      length = data.length;\n      input = palette || pixels;\n      i = j = 0;\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    };\n\n    PNG.prototype.decode = function() {\n      var ret;\n      ret = new Uint8Array(this.width * this.height * 4);\n      this.copyToImageData(ret, this.decodePixels());\n      return ret;\n    };\n\n    scratchCanvas = document.createElement(\'canvas\');\n\n    scratchCtx = scratchCanvas.getContext(\'2d\');\n\n    makeImage = function(imageData) {\n      var img;\n      scratchCtx.width = imageData.width;\n      scratchCtx.height = imageData.height;\n      scratchCtx.clearRect(0, 0, imageData.width, imageData.height);\n      scratchCtx.putImageData(imageData, 0, 0);\n      img = new Image;\n      img.src = scratchCanvas.toDataURL();\n      return img;\n    };\n\n    PNG.prototype.decodeFrames = function(ctx) {\n      var frame, i, imageData, pixels, _i, _len, _ref, _results;\n      if (!this.animation) {\n        return;\n      }\n      _ref = this.animation.frames;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        frame = _ref[i];\n        imageData = ctx.createImageData(frame.width, frame.height);\n        pixels = this.decodePixels(new Uint8Array(frame.data));\n        this.copyToImageData(imageData, pixels);\n        frame.imageData = imageData;\n        _results.push(frame.image = makeImage(imageData));\n      }\n      return _results;\n    };\n\n    PNG.prototype.renderFrame = function(ctx, number) {\n      var frame, frames, prev;\n      frames = this.animation.frames;\n      frame = frames[number];\n      prev = frames[number - 1];\n      if (number === 0) {\n        ctx.clearRect(0, 0, this.width, this.height);\n      }\n      if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {\n        ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);\n      } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {\n        ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);\n      }\n      if (frame.blendOp === APNG_BLEND_OP_SOURCE) {\n        ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);\n      }\n      return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);\n    };\n\n    PNG.prototype.animate = function(ctx) {\n      var doFrame, frameNumber, frames, numFrames, numPlays, _ref,\n        _this = this;\n      frameNumber = 0;\n      _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;\n      return (doFrame = function() {\n        var f, frame;\n        f = frameNumber++ % numFrames;\n        frame = frames[f];\n        _this.renderFrame(ctx, f);\n        if (numFrames > 1 && frameNumber / numFrames < numPlays) {\n          return _this.animation._timeout = setTimeout(doFrame, frame.delay);\n        }\n      })();\n    };\n\n    PNG.prototype.stopAnimation = function() {\n      var _ref;\n      return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);\n    };\n\n    PNG.prototype.render = function(canvas) {\n      var ctx, data;\n      if (canvas._png) {\n        canvas._png.stopAnimation();\n      }\n      canvas._png = this;\n      canvas.width = this.width;\n      canvas.height = this.height;\n      ctx = canvas.getContext("2d");\n      if (this.animation) {\n        this.decodeFrames(ctx);\n        return this.animate(ctx);\n      } else {\n        data = ctx.createImageData(this.width, this.height);\n        this.copyToImageData(data, this.decodePixels());\n        return ctx.putImageData(data, 0, 0);\n      }\n    };\n\n    return PNG;\n\n  })();\n\n  window.PNG = PNG;\n\n}).call(this);\n; // @todo in build mode\n\nvar PNG = window.PNG;\nvar KLVReader = WorkerGlobalScope.KLVReader;\n\n// Import config\n// URL of the localhost orthanc server for development purpose\nwindow.orthancUrl = \'/orthanc/\';\n;\n\nvar OrthancApiURL = window.orthancUrl;\nif (OrthancApiURL.indexOf(\'://\') === -1) {\n    // Remove bad url/cors issue induced by blob protocol.\n    OrthancApiUrl = location.origin + \'/\' + OrthancApiUrl;\n}\n// @todo out..\nvar Qualities = {\n    // 0 is reserved as none..\n    LOSSLESS: 100,\n    // THUMBNAIL\n    // MEDIUM\n    R150J100: 1, // resampling to 150 px + compressed to jpeg100\n    R1000J100: 2 // resampling to 1000 px + compressed to jpeg100\n};\n\nself.addEventListener(\'message\', function(evt) {\n    var type = evt.data.type;\n\n    switch(type) {\n    case \'getBinary\':\n        // Get an image binary\n        var id = evt.data.id;\n        var quality = evt.data.quality;\n\n        getCommand(id, quality);\n        break;\n    case \'abort\':\n        // Abort a getCommand.\n        // Do not reply anything, the reply is sent by the aborted getCommand.\n\n        abortCommand();\n        break;\n    default:\n        throw new Error(\'Unknown command\');\n    };\n}, false);\n\nvar _processingRequest = null;\n\nfunction abortCommand() {\n    if (!_processingRequest) {\n        // There is no reliable way to know from the main thread task has already been processed\n        // so we just do nothing when it\'s the case\n        return;\n    }\n\n    // Abort request (& answer via BinaryRequest failure - not sure its crossbrowser compatible)\n    _processingRequest.abort();\n}\n\nfunction getCommand(id, quality) {\n    if (_processingRequest) {\n        throw new Error(\'Another request is already in process within worker thread.\');\n    }\n\n    // Execute request\n    _processingRequest = new BinaryRequest(id, quality);\n    _processingRequest.execute();\n}\n\nfunction BinaryRequest(id, quality) {\n    this.id = id;\n    this.quality = quality;\n\n    // Parse url\n    var splittedId = id.split(\':\');\n    var instanceId = splittedId[0];\n    var frameIndex = splittedId[1] || 0;\n    \n    var url = null;\n    switch (quality) {\n    case Qualities.LOSSLESS:\n        url = OrthancApiURL + \'/nuks/\' + instanceId + \'/\' + frameIndex + \'/png\' + \'/klv\';\n        break;\n    case Qualities.R1000J100:\n        url = OrthancApiURL + \'/nuks/\' + instanceId + \'/\' + frameIndex + \'/resize:1000\' + \'/8bit\' + \'/jpeg:100\' + \'/klv\';\n        break;\n    case Qualities.R150J100:\n        url = OrthancApiURL + \'/nuks/\' + instanceId + \'/\' + frameIndex + \'/resize:150\' + \'/8bit\' + \'/jpeg:100\' + \'/klv\';\n        break;\n    default:\n        throw new Error(\'Undefined quality: \' + quality);\n    }\n\n    // Create request\n    this.xhr = new XMLHttpRequest();\n    this.xhr.open(\'GET\', encodeURI(url), true); // async xhr request because we wan\'t to be able to abort the request\n    this.xhr.responseType = \'arraybuffer\';\n}\nBinaryRequest.prototype.execute = function() {\n    var xhr = this.xhr;\n    var quality = this.quality;\n\n    xhr.onreadystatechange = function() {\n        // Only check finished requests\n        if (xhr.readyState !== XMLHttpRequest.DONE) {\n            return;\n        }\n\n        if (xhr.status === 200) {\n            // process binary out of the klv\n            var arraybuffer = xhr.response;\n            var data = parseKLV(arraybuffer);\n\n            if (data.decompression.compression === \'Jpeg\') {\n                // Decompress lossy jpeg into 16bit\n                var pixelArray = parseJpeg(data.decompression);\n                pixelArray = convertBackTo16bit(pixelArray, data.decompression);\n            }\n            else if (data.decompression.compression === \'Png\') {\n                // Decompress lossless png\n                var pixelArray = parsePng(data.decompression)\n            }\n            \n\n            // stock the format of the array, and return the array\'s buffer\n            // with its format instead of the array itself (array can\'t be worker transferable object but buffer can)\n            var pixelBufferFormat = null;\n            if (pixelArray instanceof Uint8Array) {\n                pixelBufferFormat = \'Uint8\';\n            }\n            else if (pixelArray instanceof Int8Array) {\n                pixelBufferFormat = \'Int8\';\n            }\n            else if (pixelArray instanceof Uint16Array) {\n                pixelBufferFormat = \'Uint16\';\n            }\n            else if (pixelArray instanceof Int16Array) {\n                pixelBufferFormat = \'Int16\';\n            }\n            else {\n                throw new Error("Unexpected array binary format");\n            }\n\n            // answer request to the main thread\n            self.postMessage({\n                type: \'success\',\n                cornerstoneMetaData: data.cornerstone,\n                pixelBuffer: pixelArray.buffer,\n                pixelBufferFormat: pixelBufferFormat\n            }, [pixelArray.buffer]); // pixelArray is transferable\n        }\n        else {\n            // May be called by abort (@todo not sure this behavior is crossbrowser compatible)\n\n            self.postMessage({\n                type: \'failure\',\n                status: xhr.status\n            });\n        }\n\n        // Clean the processing request when it\'s done\n        _processingRequest = null;\n    };\n\n    xhr.send(); // async call\n};\n\nBinaryRequest.prototype.abort = function() {\n    // Abort the http request\n    this.xhr.abort();\n\n    // The jpeg decompression can\'t be aborted (requires setTimeout loop during decompression to allow a function to stop it asynchronously during the event loop)\n    // Png decompression is done it two times so it could potentially be stopped at half.\n};\n\nfunction parseKLV(arraybuffer) {\n    var klvReader = new KLVReader(arraybuffer);\n    var keys = {\n        // - Cornerstone related\n        Color: 0,\n        Height: 1,\n        Width: 2,\n        SizeInBytes: 3, // size in raw prior to compression\n\n        // Pixel size / aspect ratio\n        ColumnPixelSpacing: 4,\n        RowPixelSpacing: 5,\n\n        // LUT\n        MinPixelValue: 6,\n        MaxPixelValue: 7,\n        Slope: 8,\n        Intercept: 9,\n        WindowCenter: 10,\n        WindowWidth: 11,\n\n\n        // - WebViewer related\n        IsSigned: 12,\n        Stretched: 13, // set back 8bit to 16bit if true\n        Compression: 14,\n\n        // used to zoom downsampled images back to original size\n        // cornerstone doesn\'t support this natively, it\'s done in the viewport\n        OriginalHeight: 15, \n        OriginalWidth: 16,\n\n        // - Image binary\n        ImageBinary: 17\n    };\n\n    var cornerstoneMetaData = {\n        color: klvReader.getUInt(keys.Color),\n        height: klvReader.getUInt(keys.Height),\n        width: klvReader.getUInt(keys.Width),\n        rows: klvReader.getUInt(keys.Height),\n        columns: klvReader.getUInt(keys.Width),\n        sizeInBytes: klvReader.getUInt(keys.SizeInBytes),\n\n        columnPixelSpacing: klvReader.getFloat(keys.ColumnPixelSpacing),\n        rowPixelSpacing: klvReader.getFloat(keys.RowPixelSpacing),\n\n        minPixelValue: klvReader.getInt(keys.MinPixelValue),\n        maxPixelValue: klvReader.getInt(keys.MaxPixelValue),\n        slope: klvReader.getFloat(keys.Slope),\n        intercept: klvReader.getFloat(keys.Intercept),\n        windowCenter: klvReader.getFloat(keys.WindowCenter),\n        windowWidth: klvReader.getFloat(keys.WindowWidth),\n\n        originalHeight: klvReader.getUInt(keys.OriginalHeight),\n        originalWidth: klvReader.getUInt(keys.OriginalWidth)\n    };\n\n    var compression = klvReader.getString(keys.Compression);\n    if (compression !== \'Jpeg\' && compression !== \'Png\') {\n        throw new Error(\'unknown compression\');\n    }\n\n    var decompressionMetaData = {\n        binary: klvReader.getBinary(keys.ImageBinary),\n        compression: compression,\n        width: cornerstoneMetaData.width,\n        height: cornerstoneMetaData.height,\n        hasColor: cornerstoneMetaData.color,\n        isSigned: klvReader.getUInt(keys.IsSigned),\n        stretching: !klvReader.getUInt(keys.Stretched) ? null : {\n            low: cornerstoneMetaData.minPixelValue,\n            high: cornerstoneMetaData.maxPixelValue\n        }\n    }\n\n    return {\n        cornerstone: cornerstoneMetaData,\n        decompression: decompressionMetaData\n    };\n}\n\n// if hasColor\n//  -> Uint32 == Uint8 * 4 (RGBA)\n// \n// if !hasColor && IsSigned\n//  -> Int16\n// \n// if !hasColor && !IsSigned\n//  -> Uint16\n// \nfunction parseJpeg(config) {\n    var jpegReader = new JpegImage();\n    jpegReader.parse(config.binary);\n    var s = jpegReader.getData(config.width, config.height);\n    return s;\n}\n\nfunction parsePng(config) {\n    var pixels = null;\n    var buf, index, i;\n\n    var png = new PNG(config.binary);\n\n    var s = png.decodePixels(); // returns Uint8 array\n\n    var bytePerPixel = png.bits;\n    \n    if (config.hasColor) {\n        // Convert png24 to rgb32\n\n        buf = new ArrayBuffer(s.length / 3 * 4); // RGB32\n        pixels = new Uint8Array(buf); // RGB24\n        index = 0;\n        for (i = 0; i < s.length; i += 3) {\n            pixels[index++] = s[i];\n            pixels[index++] = s[i + 1];\n            pixels[index++] = s[i + 2];\n            pixels[index++] = 255;  // Alpha channel\n        }\n    } else if (png.bits === 16) {\n        // Cast uint8_t array to (u)int16_t array\n        \n        pixels = _convertPngEndianness(s, config);\n\n    }\n    else if (png.bits === 8 && config.isSigned) {\n        pixels = new Int8Array(s.buffer);\n    }\n    else if (png.bits === 8 && !config.isSigned) {\n        pixels = new Uint8Array(s.buffer);\n    }\n    else {\n        throw new Error(\'unexpected png format\');\n    }\n\n    return pixels;\n}\n// Raw is big endian..\nfunction _convertPngEndianness(s, config) {\n    var pixels, buf, index, i, lower, upper;\n\n    buf = new ArrayBuffer(s.length * 2); // uint16_t or int16_t\n    if (config.isSigned) {\n        // pixels = new Int16Array(buf);\n        pixels = new Int16Array(s.buffer);\n    } else {\n        // pixels = new Uint16Array(buf);\n        pixels = new Uint16Array(s.buffer);\n    }\n\n    index = 0;\n    for (i = 0; i < s.length; i += 2) {\n        // PNG is little endian\n        upper = s[i];\n        lower = s[i + 1];\n        pixels[index] = lower + upper * 256;\n        index++;\n    }\n\n    return pixels;\n}\n\nfunction convertBackTo16bit(s, config) {\n    var pixels = null;\n    var buf, index, i;\n\n    if (config.hasColor) {\n        buf = new ArrayBuffer(s.length / 3 * 4); // RGB32\n        pixels = new Uint8Array(buf); // RGB24\n        index = 0;\n        for (i = 0; i < s.length; i += 3) {\n            pixels[index++] = s[i];\n            pixels[index++] = s[i + 1];\n            pixels[index++] = s[i + 2];\n            pixels[index++] = 255;  // Alpha channel\n        }\n    } else {\n        buf = new ArrayBuffer(s.length * 2); // uint16_t or int16_t\n        if (config.isSigned) {\n            pixels = new Int16Array(buf);\n        } else {\n            pixels = new Uint16Array(buf);\n        }\n\n        index = 0;\n        for (i = 0; i < s.length; i++) {\n            pixels[index] = s[i];\n            index++;\n        }\n\n        if (config.stretching) {\n            _changeDynamics(pixels, 0, config.stretching.low, 255, config.stretching.high);\n        }\n    }\n\n    return pixels;\n}\n\nfunction _changeDynamics(pixels, source1, target1, source2, target2) {\n    var scale = (target2 - target1) / (source2 - source1);\n    var offset = (target1) - scale * source1;\n\n    for (var i = 0, length = pixels.length; i < length; i++) {\n        pixels[i] = scale * pixels[i] + offset;\n    }    \n}\n'],{
type:"application/javascript"})),workerCount:6,createPromiseFn:n,taskPriorityPolicy:new osimis.TaskPriorityPolicy(u)});return window.setInterval(function(){function n(n,e){if(o[n]=o[n]||0,r[n]=r[n]||0,!(r[n]<e)){for(var t in f){if(r[n]<e)return;var i=f[t][n];if(0===i){var a=u[t][n].size||0;r[n]-=a,o[n]+=a,u[t][n]=null,delete u[t][n],"undefined"!=typeof p[t][n]&&delete p[t][n],delete f[t][n]}}console.log("flush cache q:",n,"pre:",r[n]/1024/1024,"post:",o[n]/1024/1024)}}var e,i,r={},o={};for(e in u)for(i in u[e]){var a=u[e][+i];r[+i]=r[+i]||0,a.isLoaded&&(r[+i]+=a.size)}n(t.LOSSLESS,734003200),n(t.R1000J100,734003200),n(t.R150J100,314572800)},5e3),d}n.$inject=["$q","wvConfig","WvImageQualities","wvCornerstoneImageAdapter"],angular.module("webviewer").factory("wvImageBinaryManager",n).constant("WvImageQualities",{LOSSLESS:100,R150J100:1,R1000J100:2})}(),function(){"use strict";function n(n,e,t,i,r,o,a){function s(e){var t=this;if(!p.hasOwnProperty(e)){var i=e.split("|");e=i[0];var r=i.splice(1),s=r.map(function(n){i=n.split("~");var e=i[0],t=i.splice(1);if(!u.hasOwnProperty(e))throw new Error("wv-image: unknown post processor");var r=new(Function.prototype.bind.apply(u[e],[null].concat(t)));return r});i=e.split(":");var c=i[0];i[1]||0;p[e]=n.get(o.orthancApiURL+"/instances/"+c+"/simplified-tags",{cache:!0}).then(function(n){var i=n.data;return new a(t,e,i,s)})}return p[e]}function c(n,e){u[n]=e}function l(n,o,a){function s(){d.css("overflow",u),$("#FAKE-VIEWPORT-USED-IN-IMAGE-SERVICE").remove(),c.$destroy()}var c=r.$new();c.size={width:o+"px",height:a+"px"},c.imageId=n;var l=t(['<wv-viewport id="FAKE-VIEWPORT-USED-IN-IMAGE-SERVICE"','wv-image-id="imageId"','wv-size="size"','wv-enable-overlay="false"','wv-angle-measure-viewport-tool="true"','wv-length-measure-viewport-tool="true"','wv-elliptical-roi-viewport-tool="true"','wv-zoom-viewport-tool="true"','wv-pan-viewport-tool="true"','wv-pixel-probe-viewport-tool="true"','wv-rectangle-roi-viewport-tool="true"',">","</wv-viewport>"].join("\n"))(c),d=$("body"),u=d.css("overflow");return d.css("overflow","hidden"),l.css("position","absolute"),l.css("left","-50000px"),d.append(l),e(function(n,e){i(function(){var e=null,t=l.find("canvas").get(0);e=t.toDataURL(),s(),n(e)})})}var d={get:s,createAnnotedImage:l,registerPostProcessor:c},u={},p={};return d}n.$inject=["$http","$q","$compile","$timeout","$rootScope","wvConfig","WvImage"],angular.module("webviewer").factory("wvImageManager",n)}(),function(){"use strict";function n(n,e,t,i){function r(n,e,t,i){this.id=e,this.tags=t,this.postProcesses=i||[],this.onAnnotationChanged=new osimis.Listener,this.onBinaryLoaded=new osimis.Listener,o(this),a(this)}function o(n){e.onAnnotationChanged(function(e){e.imageId===n.id&&n.onAnnotationChanged.trigger(e)})}function a(e){n.onBinaryLoaded(function(n,t,i){n===e.id&&e.onBinaryLoaded.trigger(t,i)})}return r.prototype.getAvailableQualities=function(){return i},r.prototype.getAnnotations=function(n){return e.getByImageId(this.id,n)},r.prototype.setAnnotations=function(n,i){var r=new t(n,this.id,i);e.set(r)},r.prototype.onAnnotationChanged=angular.noop,r.prototype.loadBinary=function(e){return n.get(this.id,e)},r.prototype.freeBinary=function(e){n.free(this.id,e)},r.prototype.abortBinaryLoading=function(e){n.free(this.id,e)},r.prototype.getBestQualityInCache=function(){return n.getBestQualityInCache(this.id)},r.prototype.onBinaryLoaded=angular.noop,r}n.$inject=["wvImageBinaryManager","wvAnnotationManager","WvAnnotationValueObject","WvImageQualities"],angular.module("webviewer").factory("WvImage",n)}(),function(){"use strict";function n(){function n(){}return n}angular.module("webviewer").factory("WvMask",n)}(),function(){"use strict";function n(n,e){function t(){this.masksImageIds=Array.prototype.slice.call(arguments)}function i(n){if(!n.color){var e=n.getPixelData();n.getPixelData=function(){for(var n=new ArrayBuffer(4*e.length),t=new Uint8ClampedArray(n),i=0,r=0;r<e.length;++r)t[i++]=e[r],t[i++]=e[r],t[i++]=e[r],t[i++]=255;return t},n.color=!0,n.render=cornerstone.renderColorImage}}function r(e,t){var i=n.cloneDeep(e),r=i.getPixelData(),o=t.getPixelData();return i.getPixelData=function(){for(var n=0;n<r.length;n+=4)o[n+0]>0&&(r[n+0]=r[n+0]/2+o[n+0]/2);return r},i}return t.prototype.execute=function(n,t){i(n);var o=this.masksImageIds.map(function(n){return t(n)});return e.all(o).then(function(e){return e.reduce(function(n,e){return i(e),r(n,e)},n)})},t}n.$inject=["_","$q"],angular.module("webviewer").factory("WvColorMaskPostProcessor",n).run(["wvImageManager","WvColorMaskPostProcessor",function(n,e){n.registerPostProcessor("colormask",e)}])}(),function(n){"use strict";function e(n,e,t){this.imageId=n,this.quality=e,this.promise=t,this.isLoaded=!1,this.size=void 0,this.requestHistory=[],this._lastTimeDisplayed=void 0}e.prototype.getLastTimeDisplayed=function(){return this._lastTimeDisplayed||Date.now()},e.prototype.getReferenceCount=function(){return this.requestHistory.length},e.prototype.pushPriority=function(n){var e={priority:n,timestamp:Date.now()};this.requestHistory.push(e),"display"===n&&(this._lastTimeDisplayed=void 0)},e.prototype.getPriority=function(){for(var n=null,e=0;e<this.requestHistory.length;++e){var t=this.requestHistory[e].priority;(null===n||n>t)&&(n=t)}return n},e.prototype.hasPriorityInHistory=function(n){for(var e=0;e<this.requestHistory.length;++e){var t=this.requestHistory[e];if(t.priority===n)return!0}return!1},e.prototype.popPriority=function(n){for(var e=null,t=this.requestHistory.length-1;t>=0;--t){var i=this.requestHistory[t];if(i.priority==n){e=t;break}}if(null===e)throw new Error("ImageBinaryRequest pop priority not found");this.requestHistory.splice(e,1),0!=n||this.hasPriorityInHistory(0)||(this._lastTimeDisplayed=Date.now())},e.prototype.isWaitingForDisplay=function(){for(var n=this.requestHistory.length-1;n>=0;--n){var e=this.requestHistory[n];if(0===e.priority)return!0}return!1},n.ImageBinaryRequest=e}(window.osimis||(window.osimis={})),function(){"use strict";angular.module("webviewer").run(["$rootScope","wvSerieManager","wvImageBinaryManager","WvImageQualities",function(n,e,t,i){n.$on("UserSelectedStudyId",function(n,r){e.listFromOrthancStudyId(r).then(function(n){n.forEach(function(n){for(var e=0;e<n.imageIds.length;++e){var r=n.imageIds[e],o=i.R150J100;t.requestLoading(r,o,2)}})})}),n.$on("UserUnSelectedStudyId",function(n,r){e.listFromOrthancStudyId(r).then(function(n){n.forEach(function(n){for(var e=0;e<n.imageIds.length;++e){var r=n.imageIds[e],o=i.R150J100;t.abortLoading(r,o,2)}})})}),n.$on("UserSelectedSeries",function(n,e){for(var r=0;r<e.imageIds.length;++r){var o=e.imageIds[r],a=i.R150J100;t.requestLoading(o,a,1)}for(var r=0;r<e.imageIds.length;++r){var o=e.imageIds[r],a=i.R1000J100;t.requestLoading(o,a,1)}}),n.$on("UserUnSelectedSeries",function(n,e){for(var r=0;r<e.imageIds.length;++r){var o=e.imageIds[r],a=i.R150J100;t.abortLoading(o,a,1)}for(var r=0;r<e.imageIds.length;++r){var o=e.imageIds[r],a=i.R1000J100;t.abortLoading(o,a,1)}})}])}(),function(n){"use strict";function e(n){this._imageBinaryRequests=n}e.prototype.selectTask=function(n,e,t,i){for(var r=this._imageBinaryRequests,o=t,a=[],s=[],c=[],l=0;l<o.length;++l){var d=o[l],u=d.options.id,p=d.options.quality,f=r[u][p],h=f.getPriority();switch(h){case 0:a.push({request:f,task:d});break;case 1:s.push({request:f,task:d});break;case 2:c.push({request:f,task:d})}}for(l=0;l<a.length;++l){var d=a[0].task,f=a[0].request;if(1===f.quality)return d}for(l=0;l<a.length;++l){var d=a[0].task,f=a[0].request;if(2===f.quality)return d}for(l=0;l<a.length;++l){var d=a[0].task,f=a[0].request;if(100===f.quality)return d}if(!(n.length<2)){for(l=0;l<s.length;++l){var d=s[0].task,f=s[0].request;if(1===f.quality)return d}for(l=0;l<s.length;++l){var d=s[0].task,f=s[0].request;if(2===f.quality)return d}for(l=0;l<s.length;++l){var d=s[0].task,f=s[0].request;if(100===f.quality)return d}for(l=0;l<c.length;++l){var d=c[0].task,f=c[0].request;if(1===f.quality)return d}for(l=0;l<c.length;++l){var d=c[0].task,f=c[0].request;if(2===f.quality)return d}for(l=0;l<c.length;++l){var d=c[0].task,f=c[0].request;if(100===f.quality)return d}return t[0]||null}},n.TaskPriorityPolicy=e}(window.osimis||(window.osimis={})),function(n){"use strict";function e(e){this.type=e.type,this.options=e,this.onSucceed=new n.Listener,this.onFailure=new n.Listener,this.onAbort=new n.Listener}e.prototype.abort=function(){this.onAbort.trigger()},n.Task=e}(window.osimis||(window.osimis={})),function(n){"use strict";function e(e){var t=this;this._workerThread=new Worker(e),this._currentTask=null,this.onAvailable=new n.Listener,this._workerThread.addEventListener("message",function(n){var e=t._currentTask;switch(n.data.type){case"success":e.onSucceed.trigger(n.data);break;case"failure":e.onFailure.trigger(n.data);break;default:throw new Error("Unknown worker response type")}t._currentTask.onAbort.close(t),t._currentTask=null,t.onAvailable.trigger()},!1),this._workerThread.addEventListener("error",function(n){var e=t._currentTask;e.onFailure.trigger(n.data),t._currentTask.onAbort.close(t),t._currentTask=null,t.onAvailable.trigger()},!1)}e.prototype.processTask=function(n){var e=this;if(this._currentTask)throw new Error("Worker is busy");this._currentTask=n,n.onAbort(this,function(){e._workerThread.postMessage({type:"abort"})}),e._workerThread.postMessage(n.options)},n.TaskWorker=e}(window.osimis||(window.osimis={})),function(n){"use strict";function e(e){var t=this;if(this._path=e.path,this._workerCount=e.workerCount||1,!e.createPromiseFn)throw new Error("createPromiseFn argument required");this._createPromiseFn=e.createPromiseFn,this._availableTaskWorkers=[],this._busyTaskWorkers=[],this._tasksToProcess=[],this._tasksInProcess=[],this._taskPriorityPolicy=e.taskPriorityPolicy;for(var i=0;i<this._workerCount;++i){var r=new n.TaskWorker(this._path);this._availableTaskWorkers.push(r),function(n){n.onAvailable(function(){_.pull(t._busyTaskWorkers,n),t._availableTaskWorkers.push(n),t._processQueuedTaskInAvailableWorker()})}(r)}}e.prototype.queueTask=function(e){var t=this,i=new n.Task(e);return this._tasksToProcess.push(i),this._processQueuedTaskInAvailableWorker(),this._createPromiseFn(function(n,e){i.onSucceed(t.queueTask,function(e){i.onFailure.close(t.queueTask),i.onSucceed.close(t.queueTask),n(e)}),i.onFailure(t.queueTask,function(n){i.onFailure.close(t.queueTask),i.onSucceed.close(t.queueTask),e(n)})})},e.prototype.abortTask=function(n){_.pullAllWith(this._tasksToProcess,[n],function(n,e){return _.isEqual(n.options,e)});for(var e=this._tasksInProcess.length-1;e>=0;--e){var t=this._tasksInProcess[e];_.isEqual(t.options,n)&&(t.abort(),_.pull(this._tasksInProcess,t))}},e.prototype._processQueuedTaskInAvailableWorker=function(){var n=this;window.setTimeout(function(){if(0!==n._availableTaskWorkers.length&&0!==n._tasksToProcess.length){var e=n._taskPriorityPolicy.selectTask(n._availableTaskWorkers,n._busyTaskWorkers,n._tasksToProcess,n._tasksInProcess);if(e){var t=n._availableTaskWorkers[0];_.pull(n._tasksToProcess,e),n._tasksInProcess.push(e),_.pull(n._availableTaskWorkers,t),n._busyTaskWorkers.push(t),e.onSucceed(n._processQueuedTaskInAvailableWorker,function(){e.onSucceed.close(n._processQueuedTaskInAvailableWorker),e.onFailure.close(n._processQueuedTaskInAvailableWorker),_.pull(n._tasksInProcess,e)}),e.onFailure(n._processQueuedTaskInAvailableWorker,function(){e.onSucceed.close(n._processQueuedTaskInAvailableWorker),e.onFailure.close(n._processQueuedTaskInAvailableWorker),_.pull(n._tasksInProcess,e)}),t.processTask(e)}}})},n.WorkerPool=e}(window.osimis||(window.osimis={})),function(){"use strict";function n(){function n(n,e,t,i){var r=this;i.serie&&i.droppableSerieExt?(n.show=!i.serie.hasSerie(),i.serie.onSerieChanged(r,function(e){n.show=!i.serie.hasSerie()}),n.$on("$destroy",function(){i.serie.onSerieChanged.close(r)})):n.show=!1}var t={bindToController:!0,controller:e,controllerAs:"vm",link:n,restrict:"E",transclude:!0,require:{serie:"?^^wvSerieId",droppableSerieExt:"?^^wvDroppableSerieExt"},templateUrl:"app/overlay/droppable-serie-overlay-item.directive.html",scope:{}};return t}function e(){}angular.module("webviewer").directive("wvDroppableSerieOverlayItem",n)}(),function(){"use strict";function n(){function n(n,e,t){n.vm.imageQualities=[]}var t={templateNamespace:"svg",replace:!0,templateUrl:"app/overlay/loading-bar.directive.html",bindToController:!0,controller:e,controllerAs:"vm",link:n,restrict:"E",scope:{serie:"=wvSerie"}};return t}function e(n,e,t){var i=this;this.imageQualities=[],this.bestQualityByImage=[],this.QualityKeys=_.invert(t),this.currentImageIndex=null,n.$watch("vm.serie",function(n,e){e&&(e.onCurrentImageIdChanged.close(i),i.imageQualities=[],i.imageCount=0,i.imageBarWidth=0),n&&(i.currentImageIndex=n.currentIndex,i.imageCount=n.imageCount,i.imageBarWidth=100/i.imageCount,n.onCurrentImageIdChanged(i,function(e){i.currentImageIndex=n.getIndexOf(e)}),i.imageQualities=n.listCachedImageBinaries(),i.bestQualityByImage=i.imageQualities.map(function(n){var e=n.reduce(function(n,e){return null===n||e>n?e:n},null);return e}))}),e.onBinaryLoaded(i,function(n,e){var t=i.serie;if(t){var r=t.getIndexOf(n);-1!==r&&(i.imageQualities[r].push(e),(!i.bestQualityByImage[r]||e>i.bestQualityByImage[r])&&(i.bestQualityByImage[r]=e))}}),e.onBinaryUnLoaded(i,function(n,e){var t=i.serie;if(t){var r=t.getIndexOf(n);-1!==r&&(_.pull(i.imageQualities[r],e),i.bestQualityByImage=i.imageQualities.map(function(n){var e=n.reduce(function(n,e){return null===n||e>n?e:n},null);return e}))}}),n.$on("$destroy",function(){e.onBinaryLoaded.close(i),e.onBinaryUnLoaded.close(i)})}e.$inject=["$scope","wvImageBinaryManager","WvImageQualities"],angular.module("webviewer").directive("wvLoadingBar",n),e.prototype._listenSerie=function(){},e.prototype._unlistenSerie=function(){}}(),function(){"use strict";function n(){function n(n,e,t,i){var r=this;n.vm.showTopLeftArea=function(){return!!n.vm.wvTags},n.vm.showTopRightArea=function(){return!!n.vm.wvTags&&!!n.vm.wvTags.SeriesDescription&&!!n.vm.wvTags.SeriesNumber},n.vm.showBottomRightArea=function(){return!!n.vm.wvViewport&&!!n.vm.wvTags},n.vm.wvShowTimeline="undefined"==typeof n.vm.wvShowTimeline?!0:n.vm.wvShowTimeline,n.vm.showTimeline=!1,n.vm.wvShowTimeline&&i.serie&&(i.serie.onSerieChanged(r,function(e){n.vm.wvSerie=e,n.vm.showTimeline=n.vm.wvShowTimeline&&!!e.imageCount}),n.$on("$destroy",function(){i.serie.onSerieChanged.close(r)}))}var t={bindToController:!0,controller:e,controllerAs:"vm",replace:!0,link:n,restrict:"E",transclude:!0,require:{serie:"?^^wvSerieId"},templateUrl:"app/overlay/overlay.directive.html",scope:{wvTags:"=?",wvSerie:"=?",wvViewport:"=?",wvShowTimeline:"=?"}};return t}function e(){}angular.module("webviewer").directive("wvOverlay",n)}(),function(){"use strict";function n(){function n(n,e,t){function i(){var e=Math.ceil(100*(n.vm.wvShownImageIndex+1)/n.vm.wvImageCount);n.vm.loadedScrollbarDistanceFromRight=100-e+"%"}function r(){var e=Math.ceil(100*(n.vm.wvImageIndex+1)/n.vm.wvImageCount);n.vm.loadingScrollbarDistanceFromRight=100-e+"%"}n.vm.loadedScrollbarDistanceFromRight="0%",n.vm.loadingScrollbarDistanceFromRight="0%",n.$watchGroup(["vm.wvShownImageIndex","vm.wvImageCount"],i),n.$watchGroup(["vm.wvImageIndex","vm.wvImageCount"],r)}var t={templateUrl:"app/overlay/scrollbar-overlay-item.directive.html",bindToController:!0,controller:e,controllerAs:"vm",link:n,restrict:"E",scope:{wvImageCount:"=",wvShownImageIndex:"=",wvImageIndex:"="}};return t}function e(){}angular.module("webviewer").directive("wvScrollbarOverlayItem",n)}(),function(){"use strict";function n(n){function e(e,t,i){var r=t.SlicesShort.map(function(n){for(var e=n[0],t=n[2],i=[],r=0;t>r;++r)i.push(e+":"+r);return i}),o=r.filter(function(n){return 1===n.length}).length===r.length;if(o)var a=[_.flatten(r)];else var a=r;var s=a.map(function(t,r){var o=e.ID+":"+r;return i=i||e.MainDicomTags,new n(o,t,i)});return s}var t={process:e};return t}n.$inject=["WvSerie"],angular.module("webviewer").factory("wvOrthancSerieAdapter",n)}(),function(){"use strict";function n(n,e,t,i){function r(n){var e=n.split(":"),t=e[0],i=e[1]||0;return s.listFromOrthancSerieId(t).then(function(n){return n[i]})}function o(r){var o=e.get(t.orthancApiURL+"/series/"+r,{cache:!0}),a=e.get(t.orthancApiURL+"/series/"+r+"/ordered-slices",{cache:!0});return a.then(function(i){var r=i.data.SlicesShort[0][0],a=e.get(t.orthancApiURL+"/instances/"+r+"/simplified-tags",{cache:!0});return n.all({orthancSerie:o,orthancOrderedInstances:i,tags:a})}).then(function(n){var e=n.orthancSerie.data,t=n.orthancOrderedInstances.data,r=n.tags.data;return i.process(e,t,r)})}function a(i){return e.get(t.orthancApiURL+"/studies/"+i,{cache:!0}).then(function(e){var t=e.data,i=t.Series,r=i.map(function(n){return s.listFromOrthancSerieId(n)});return n.all(r)}).then(function(n){return n=_.flatten(n)})}var s={get:r,listFromOrthancSerieId:o,listFromOrthancStudyId:a};return s}n.$inject=["$q","$http","wvConfig","wvOrthancSerieAdapter"],angular.module("webviewer").factory("wvSerieManager",n)}(),function(){"use strict";function n(n,e,t,i,r){function o(n,e,i){var r=this;this.id=n,this.imageIds=e,this.imageCount=e.length,this.currentIndex=0,this.currentShownIndex=0,this.tags=i,this.onCurrentImageIdChanged=new osimis.Listener,this.onAnnotationChanged=new osimis.Listener,this._annotationGroup=null,t.onAnnotationChanged(function(n){-1!==r.imageIds.indexOf(n.imageId)&&(r._annotationGroup=null,r.onAnnotationChanged.trigger(n))}),this.isPlaying=!1,this._playTimeout=null}o.prototype.listCachedImageBinaries=function(){return this.imageIds.map(function(n,e){return r.listCachedBinaries(n)})},o.prototype.getAnnotedImageIds=function(n){return this._loadAnnotationGroup().filterByType(n).getImageIds()},o.prototype.getAnnotationGroup=function(n){return this._loadAnnotationGroup()},o.prototype.getAnnotations=function(n){var e=this._loadAnnotationGroup();return n&&e.filterByType(n),e.toArray()},o.prototype.getIndexOf=function(n){return this.imageIds.indexOf(n)},o.prototype.setShownImage=function(n){this.currentShownIndex=this.getIndexOf(n)},o.prototype.getCurrentImageId=function(){return this.imageIds[this.currentIndex]},o.prototype.goToNextImage=function(n){n=n||!1,this.currentIndex>=this.imageCount-1&&n?(this.currentIndex=0,this.onCurrentImageIdChanged.trigger(this.getCurrentImageId(),this.setShownImage.bind(this))):this.currentIndex<this.imageCount-1&&(this.currentIndex++,this.onCurrentImageIdChanged.trigger(this.getCurrentImageId(),this.setShownImage.bind(this)))},o.prototype.goToPreviousImage=function(){this.currentIndex>0&&(this.currentIndex--,this.onCurrentImageIdChanged.trigger(this.getCurrentImageId(),this.setShownImage.bind(this)))},o.prototype.goToImage=function(n){if(0>n)n=0;else if(n+1>this.imageCount)return;this.currentIndex!=n&&(this.currentIndex=n,this.onCurrentImageIdChanged.trigger(this.getCurrentImageId(),this.setShownImage.bind(this)))};var a=null;return o.prototype.play=function(){var e=this;if(!(this.imageCount<2)){var t=1e3/this.tags.RecommendedDisplayFrameRate||1e3/30;if(!this.isPlaying){var i=null,r=0;!function o(){a=requestAnimationFrame(function(a){if(r)--r;else{var s=1e3/(a-i);r=Math.round(s/t),n.$apply(function(){e.goToNextImage(!0)})}i=a,e.isPlaying&&o()})}(),this.isPlaying=!0}}},o.prototype.pause=function(){a&&(cancelAnimationFrame(a),a=null),this.isPlaying=!1},o.prototype._loadAnnotationGroup=function(){if(!this._annotationGroup){var n=[];this.imageIds.forEach(function(e){n.push(t.getByImageId(e))}),this._annotationGroup=new i(n)}return this._annotationGroup},o}n.$inject=["$rootScope","$timeout","wvAnnotationManager","WvAnnotationGroup","wvImageBinaryManager"],angular.module("webviewer").factory("WvSerie",n)}(),angular.module("webviewer").directive("wvSerielist",["wvSerieManager",function(n){return{scope:{wvStudy:"=",wvClassTmp:"=?wvClass"},templateUrl:"app/serielist/serielist.directive.html",restrict:"E",transclude:!0,link:function(e,t,i){function r(t,i){t&&n.listFromOrthancStudyId(t).then(function(n){e.serieIds=n.map(function(n){return n.id})})}function o(){e.wvClass=e.wvClassTmp||{};var n={ul:e.wvClass.ul||"wv-serielist",li:e.wvClass.li||"wv-serielist-item",overlay:e.wvClass.ul||"wv-serielist-overlay"};e.wvClass=n}e.$watchCollection("wvClassTmp",function(){o()}),e.$watch("wvStudy.id",r),e.serieIds=[]}}}]),angular.module("webviewer").directive("wvSplitpane",["$","$timeout",function(n,e){return{scope:{wvLayout:"=?",wvSettings:"=?"},templateUrl:"app/splitpane/splitpane.directive.html",restrict:"E",transclude:!0,link:function(t,i,r,o,a){function s(i,r){i&&(t.x=[i.x],t.y=[i.y],t.rowHeight=100/i.y+"%",t.rowWidth=100/i.x+"%",e(function(){n(window).resize()}))}t.showDefaultContent=!1,a(function(n){_.filter(n,function(n){return n instanceof HTMLElement||_.trim(n.textContent).length}).length||(t.showDefaultContent=!0)}),t.wvLayout=t.wvLayout||t.wvSettings&&t.wvSettings.layout||{x:1,y:1},t.$watch("wvLayout",s,!0)}}}]),angular.module("webviewer").directive("wvToolbarAction",["$parse",function(n){return{require:["^^wvToolbar"],scope:!0,templateUrl:"app/toolbar/wv-toolbar-action.tpl.html",restrict:"E",link:function(e,t,i){e.wvName=i.wvName,e.wvIcon=i.wvIcon,e.wvAction=n(i.wvAction).bind(n,e)},controller:function(){}}}]),angular.module("webviewer").directive("wvToolbarSetting",["_",function(n){return{scope:!0,templateUrl:"app/toolbar/wv-toolbar-setting.tpl.html",restrict:"E",link:function(e,t,i){e.wvName=i.wvName,e.wvIcon=i.wvIcon,e.wvChoices=n.map(e.$eval(i.wvChoices),function(n,e){return{value:n,label:e}})}}}]),angular.module("webviewer").directive("wvToolbarState",function(){return{require:["^^wvToolbar"],scope:!0,templateUrl:"app/toolbar/wv-toolbar-state.tpl.html",restrict:"E",link:function(n,e,t){n.wvName=t.wvName,n.wvIcon=t.wvIcon,n.wvIconOn=t.wvIconOn,n.wvIconOff=t.wvIconOff},controller:function(){}}}),angular.module("webviewer").directive("wvToolbarTool",function(){return{require:["^^wvToolbar"],scope:!0,templateUrl:"app/toolbar/wv-toolbar-tool.tpl.html",restrict:"E",link:function(n,e,t){n.wvName=t.wvName,n.wvIcon=t.wvIcon},controller:function(){}}}),angular.module("webviewer").directive("wvToolbar",["_",function(n){return{scope:{wvItems:"=",activeTool:"=?wvActiveTool"},templateUrl:"app/toolbar/wv-toolbar.tpl.html",transclude:!0,restrict:"E",link:function(n,e,t){},controller:["$timeout","$scope",function(e,t){t.activeTool=t.activeTool||"windowing",t.activeStates={},t.splitpaneConfig={x:1,y:1},t.$watch("activeTool",function(n,i){t.wvItems.hasOwnProperty(i)&&(t.wvItems[i]=!1),e(function(){t.wvItems[n]=!0})}),t.$watchCollection("activeStates",function(e){n.forEach(e,function(n,e){t.wvItems.hasOwnProperty(e)&&(t.wvItems[e]=n)})}),t.activeButton=null,void 0!=t.wvItems&&n.size(t.wvItems)||(t.wvItems={windowing:!0,zoom:!1,pan:!1,invert:!1,lengthmeasure:!1,anglemeasure:!1,pixelprobe:!1,ellipticalroi:!1,rectangleroi:!1,layout:{x:1,y:1},play:!1,overlay:!0,vflip:!1,hflip:!1,rotateleft:!1,rotateright:!1}),this.set=function(n){var i=t.activeButton,r=n;i!=r&&(null!==i&&t.$broadcast("toolbar.deactivated",i),t.activeButton=r,null!==r&&e(function(){t.$broadcast("toolbar.activated",r)}))},this.get=function(){return t.activeButton}}]}}]),function(n){"use strict";function e(){function n(n,t){var i=t||n,r=t&&n;r&&(i.namespace=r),e.push(i)}var e=[],i=0;return n.once=function(e){var t=i++;n(".<_^_>. ]MONDOSHAWANS"+t+"[ .<_^_>.",function(){e.apply(this,arguments),n.close(".<_^_>. ]MONDOSHAWANS"+t+"[ .<_^_>.")})},n.close=function(n){n?_.remove(e,function(e){return e.namespace&&t(e.namespace,n)}):e=[]},n.ignore=function(n,i){e.forEach(function(e){t(e.namespace,n)&&(e.ignore=!0)}),i(),e.forEach(function(e){t(e.namespace,n)&&(e.ignore=!1)})},n.trigger=function(){var n=Array.prototype.splice.call(arguments,0);e.filter(function(n){return!n.ignore}).forEach(function(e){e.apply(null,n)})},n}function t(n,e){return _.isArray(n)&&_.isArray(e)?_.isEqualWith(n,e,function(n,e){return n.length===e.length&&n.reduce(function(n,t,i){return n&&t===e[i]},!0)}):n===e}n.Listener=e}(window.osimis||(window.osimis={})),function(){"use strict";function n(n,t,i){function o(n,e,o,a){if(e.parent().length){var s=t(o.wvSize);n.$watch(s,function(n,e){var t=n.width,i=n.height;"undefined"!=typeof t&&"undefined"!=typeof i&&a.updateSize(t,i)},!0);var c=i(function(){n.$apply(function(){var e=s(n);(r(e.width)||r(e.height))&&a.updateSize(e.width,e.height)})},10);$(window).on("resize",c),n.$on("$destroy",function(){$(window).off("resize",c)})}}var a={controller:e,link:{pre:o},restrict:"A",scope:!1,require:"wvSize",priority:100};return a}function e(n,e,a,s,c){var l=e(s.wvSize),d=[];this.onUpdate=function(e){return d.push(e),function(){n.pull(d,e)}},this.updateSize=function(n,e){var o=null,s=l.assign;if(s&&s(a,{width:n,height:e}),r(n)){if(o=o||c.closest("[wv-size-tag]"),!o.length)throw new Error("wv-size#updateSize: [wv-size-tag] not found");n=o.width()+"px"}if(r(e)){if(o=o||c.closest("[wv-size-tag]"),!o.length)throw new Error("wv-size#updateSize: [wv-size-tag] not found");e=o.height()+"px"}if(t(n)&&t(e))this.setSpecificWidthAndSpecificHeight(n,e);else if(t(n)&&i(e))this.setSpecificWidthAndScaleHeight(n,e);else{if(!t(e)||!i(n))throw new Error("wv-size: unsupported options");this.setSpecificHeightAndScaleWidth(e,n)}},this.setWidth=function(n){var e=l(a).height;this.updateSize(n,e)},this.setHeight=function(n){var e=l(a).width;this.updateSize(e,n)},this.getWidthInPixel=function(){var n=l(a).width;return o(n)?+n.replace("px",""):+c.width()},this.getHeightInPixel=function(){var n=l(a).height;return o(n)?+n.replace("px",""):+c.height()},this.setSpecificWidthAndSpecificHeight=function(n,e){c.css("width",n),c.css("height",e),d.forEach(function(n){n()})},this.setSpecificWidthAndScaleHeight=function(n,e){var t=n.replace(/^([0-9]+)(\w+)$/,function(n,t,i){return t*e+i});c.css("width",n),c.css("height",t),d.forEach(function(n){n()})},this.setSpecificHeightAndScaleWidth=function(n,e){var t=n.replace(/^([0-9]+)(\w+)$/,function(n,t,i){return t*e+i});c.css("height",n),c.css("width",t),d.forEach(function(n){n()})}}function t(n){return _.isString(n)&&n.match(/^[0-9]+\w+$/)}function i(n){return _.isNumber(n)}function r(n){return _.isString(n)&&"[wv-size-tag]"===n}function o(n){return _.isString(n)&&n.match(/^[0-9]+(px)?$/)}n.$inject=["$timeout","$parse","debounce"],e.$inject=["_","$parse","$scope","$attrs","$element"],angular.module("webviewer").directive("wvSize",n)}(),angular.module("webviewer").directive("wvStudylist",["$rootScope","$http","wvConfig",function(n,e,t){return{scope:{wvSelectedStudy:"="},template:['<button type="button" class="btn btn-default wv-studylist" ','ng-model="wvSelectedStudy" placeholder="Study.." ','bs-options="study.value as study.label for study in studies"'," bs-select>","</button>"].join(""),restrict:"E",link:function(i,r,o){i.studies=[],e.get(t.orthancApiURL+"/studies/",{cache:!0}).then(function(n){var r=n.data;i.studies=r.map(function(n){return{label:"?",value:{id:n}}}),i.studies.forEach(function(n){e.get(t.orthancApiURL+"/studies/"+n.value.id,{cache:!0}).then(function(e){var t=e.data;n.label=t.MainDicomTags.StudyDescription})})}),i.$watch("wvSelectedStudy",function(e,t){t&&t.id&&e!==t&&n.$emit("UserUnSelectedStudyId",t.id),e&&e.id&&n.$emit("UserSelectedStudyId",e.id)})}}}]),function(n){"use strict";function e(e,t,i,r){this._canvasWidth=e,this._canvasHeight=t,this._image=i,this._desiredQuality=null,this._actualQuality=null,this._resetParameters=!1,this._isImageLoaded=!1,this._binariesInLoading=[],this._isDestroyed=!1,this._lastLoadedImageQuality=null,this._actualResolutionScale=r||null,this.onImageLoaded=new n.Listener,this.onLoadingCancelled=new n.Listener,this.onParametersResetting=new n.Listener,this.onImageLoading=new n.Listener}e.prototype.destroy=function(){var n=this;this._isDestroyed=!0,this._binariesInLoading.forEach(function(e){try{n._image.abortBinaryLoading(e)}catch(t){}}),this.onImageLoading.close(),this.onLoadingCancelled.close(),this.onImageLoaded.close(),this.onParametersResetting.close(),this._image.onAnnotationChanged.close(n),this._lastLoadedImageQuality&&(this._image.freeBinary(this._lastLoadedImageQuality),this._image=null,this._lastLoadedImageQuality=null)},e.prototype.resetParameters=function(){this._resetParameters=!0},e.prototype.setLosslessQuality=function(){var n=this._image.getAvailableQualities();this._desiredQuality=n.LOSSLESS},e.prototype.setQualityBasedOnCanvasSize=function(){var n=this._image.getAvailableQualities(),e=null;e=this._canvasWidth<=150||this._canvasHeight<=150?n.R150J100:this._canvasWidth<=1e3||this._canvasHeight<=1e3?n.R1000J100:n.LOSSLESS,this._desiredQuality=e},e.prototype._loadImageBinaries=function(n){var e=this,t=this._image,i=t.getAvailableQualities(),r=t.getBestQualityInCache()||0,o=this._desiredQuality>r?this._desiredQuality:r;for(var a in i){var s=i[a];if(s>=r&&o>=s){var c=t.loadBinary(s);!function(t){c.then(function(i){_.pull(e._binariesInLoading,t),n(t,i)},function(n){_.pull(e._binariesInLoading,t),e.onLoadingCancelled.trigger(n)})}(s),e._binariesInLoading.push(s)}}},e.prototype.resizeCanvas=function(n,e,t){this._canvasWidth=e,this._canvasHeight=t;var i=cornerstone.getImage(n),r=cornerstone.getViewport(n);if(i&&r){this._resetCornerstoneViewportData(n,i);var r=cornerstone.getViewport(n),o=cornerstone.getEnabledElement(n);o.viewport=r,o.image=i,cornerstone.updateImage(n,!0),$(o.element).trigger("CornerstoneImageRendered",{viewport:o.viewport,element:o.element,image:o.image,enabledElement:o,canvasContext:o.canvas.getContext("2d")})}},e.prototype._resetCornerstoneViewportData=function(n,e){var t=cornerstone.getDefaultViewportForImage(n,e),i=e.originalWidth/e.width,r=e.originalWidth<=this._canvasWidth&&e.originalHeight<=this._canvasHeight;if(r)t.scale=1*i;else{var o=this._canvasHeight/e.originalHeight*i,a=this._canvasWidth/e.originalWidth*i;o>a?t.scale=a:t.scale=o}var s=cornerstone.getEnabledElement(n);s.viewport=t,this.onParametersResetting.trigger(t)},e.prototype._adaptAnnotationsResolution=function(n,e){var t=this._image,i=t.getAnnotations(),r=e.originalWidth/e.width,o={length:["handles.start.x","handles.start.y","handles.end.x","handles.end.y"],rectangleRoi:["handles.start.x","handles.start.y","handles.end.x","handles.end.y"],ellipticalRoi:["handles.start.x","handles.start.y","handles.end.x","handles.end.y"],angle:["handles.start.x","handles.start.y","handles.start2.x","handles.start2.y","handles.end.x","handles.end.y","handles.end2.x","handles.end2.y"],probe:["handles.end.x","handles.end.y"]};i.forEach(function(n){if(o.hasOwnProperty(n.type)){var e=n.data.scale||1,i=e/r,a=n.data.data,s=o[n.type];a.forEach(function(n){_.at(n,s).forEach(function(e,t){var r=s[t],o=e*i;_.set(n,r,o)})}),n.data.scale=r,t.setAnnotations(n.type,n.data)}})},e.prototype._adaptImageResolution=function(n,e){var t=cornerstone.getViewport(n),i=this._actualResolutionScale||1,r=e.originalWidth/e.width,o=t.scale,a=o/i*r;t.scale=a;var s=a/o;t.translation.x=t.translation.x/s,t.translation.y=t.translation.y/s,this._actualResolutionScale=r;var c=cornerstone.getEnabledElement(n);c.viewport=t},e.prototype.draw=function(n){function e(e,i){if(t._isDestroyed)return void t.onLoadingCancelled.trigger();var r=t._actualQuality||0,o=e;if(r>=o)return void t._image.freeBinary(o);null!==t._lastLoadedImageQuality&&t._image.freeBinary(t._lastLoadedImageQuality),t._lastLoadedImageQuality=e;var a=cornerstone.getViewport(n);if(a||(t._resetParameters=!0),t._isImageLoaded&&t._image.onAnnotationChanged.close(t),t._image.onAnnotationChanged(t,function(n){n&&n.data&&"undefined"==typeof n.data.scale&&(n.data.scale=i.originalWidth/i.width)}),!t._isImageLoaded&&t._resetParameters)t._resetCornerstoneViewportData(n,i),t._adaptAnnotationsResolution(n,i),t._resetParameters=!1;else if(t._isImageLoaded&&!t._resetParameters)t._adaptImageResolution(n,i),t._adaptAnnotationsResolution(n,i);else{if(t._isImageLoaded||t._resetParameters)throw new Error("Unknown state");
t._adaptImageResolution(n,i),t._adaptAnnotationsResolution(n,i)}t._actualResolutionScale=i.originalWidth/i.width,t.onImageLoading.trigger();var s=cornerstone.getEnabledElement(n);s.image=i,cornerstone.updateImage(n,!0),$(s.element).trigger("CornerstoneImageRendered",{viewport:s.viewport,element:s.element,image:s.image,enabledElement:s,canvasContext:s.canvas.getContext("2d")}),$(n).find("canvas").css("visibility","visible"),t._actualQuality=o,t._isImageLoaded||(t._isImageLoaded=!0),t.onImageLoaded.trigger(o)}var t=this;this._loadImageBinaries(e)},n.ImageDisplayer=e}(window.osimis||(window.osimis={})),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvAngleMeasureViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"angle")}var r={require:"wvAngleMeasureViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvAngleMeasureViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvAngleMeasureViewportTool="?^wvAngleMeasureViewportTool",n}])}])}(),function(){"use strict";function n(n,e,t,i,r,o){function a(n){this.viewports=[],this.toolName=n,this.isActivated=!1}a.prototype.register=function(n){this.viewports.push(n),this._listenModelChange(n),this.isActivated&&this.activate(n)},a.prototype.unregister=function(n){this._unlistenModelChange(n),i.pull(this.viewports,n)},a.prototype._activateInputs=function(n){var e=n.getEnabledElement();r.mouseInput.enable(e),r[this.toolName].activate(e,!0)},a.prototype._deactivateInputs=function(n){var e=n.getEnabledElement();r[this.toolName].deactivate(e),r.mouseInput.disable(e)};return a.prototype._listenModelChange=function(n){var e=this,t=(this.toolName,n.getEnabledElement()),i=r.getElementToolStateManager(t),o=n.getImage(),a=o.getAnnotations(e.toolName);a&&i.restoreStateByToolAndImageId(a.type,a.imageId,a.data,!1),o.onAnnotationChanged([e,n],function(n){n.type===e.toolName&&i.restoreStateByToolAndImageId(n.type,n.imageId,n.data,!0)}),n.onImageChanging(this,function(t,r){r&&r.onAnnotationChanged.close([e,n]);var o=t.getAnnotations(e.toolName);o&&i.restoreStateByToolAndImageId(o.type,o.imageId,o.data,!1),t.onAnnotationChanged([e,n],function(n){n.type===e.toolName&&i.restoreStateByToolAndImageId(n.type,n.imageId,n.data,!0)})})},a.prototype._unlistenModelChange=function(n){var e=n.getImage();e&&e.onAnnotationChanged.close([this,n]),n.onImageChanging.close(this)},a.prototype._listenViewChange=function(e){var o=this,a=e.getEnabledElement(),s=r.getElementToolStateManager(a);t(a).on("CornerstoneImageRendered."+this.toolName,i.debounce(function(){var t=e.getImage(),r=s.getStateByToolAndImageId(o.toolName,t.id),a=t.getAnnotations(o.toolName);a&&i.isEqual(r,a.data)||n.$apply(function(){var n=i.clone(r);t.onAnnotationChanged.ignore([o,e],function(){n&&n.data.length?t.setAnnotations(o.toolName,n):n&&!n.data.length&&t.setAnnotations(o.toolName,null)})})},20))},a.prototype._unlistenViewChange=function(n){var e=n.getEnabledElement();t(e).off("CornerstoneImageRendered."+this.toolName)},a.prototype._process=function(n){},a.prototype._unprocess=function(n){},a.prototype.activate=function(n){if("undefined"==typeof n)this.viewports.forEach(this.activate.bind(this)),this.isActivated=!0;else{n.getEnabledElement();this._process(n),this._activateInputs(n),this._listenViewChange(n)}},a.prototype.deactivate=function(n){var e=this;this.viewports.forEach(function(n){e._unlistenViewChange(n),e._deactivateInputs(n),e._unprocess(n)}),this.isActivated=!1},a}n.$inject=["$rootScope","$timeout","$","_","cornerstoneTools","debounce"],angular.module("webviewer").factory("WvBaseTool",n)}(),function(){"use strict";function n(n,e,t){function i(n,t,i,r){var o=e(i.wvDefaultViewportTool);n.$watch(o,function(n){n?r.activate():r.deactivate()})}function r(e){t.call(this,"default"),this._activateInputs=function(t){var i=this,r=n(t.getEnabledElement());r.on("mousedown.dvt",function(r){var o=r.pageX,a=r.pageY,s=r.which;n(document).on("mousemove.dvt",function(r){e.$apply(function(){var n=r.pageX-o,e=r.pageY-a;o=r.pageX,a=r.pageY,1===s?i.setWindowing(t,n,e):2===s?i.pan(t,n,e):3===s&&i.zoom(t,e)}),n(document).one("mouseup",function(e){n(document).unbind("mousemove.dvt")})})})},this._deactivateInputs=function(e){var t=n(e.getEnabledElement());t.off("mousedown.dvt")},this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop,this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this.setWindowing=function(n,e,t){var i=n.getViewport(),r=+i.scale,o=+i.voi.windowWidth,a=+i.voi.windowCenter;i.voi.windowWidth=o+e/r,i.voi.windowCenter=a+t/r,n.setViewport(i)},this.pan=function(n,e,t){var i=n.getViewport(),r=+i.scale,o=+i.translation.x,a=+i.translation.y;i.translation.x=o+e/r,i.translation.y=a+t/r,n.setViewport(i)},this.zoom=function(n,e){var t=n.getViewport(),i=+t.scale;t.scale=i+e/100,n.setViewport(t)}}r.$inject=["$scope"];var o={require:"wvDefaultViewportTool",controller:r,link:i,restrict:"A",scope:!1};return r.prototype=Object.create(t.prototype),r.prototype.constructor=r,o}n.$inject=["$","$parse","WvBaseTool"],angular.module("webviewer").directive("wvDefaultViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvDefaultViewportTool="?^wvDefaultViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvEllipticalRoiViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"ellipticalRoi")}var r={require:"wvEllipticalRoiViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvEllipticalRoiViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvEllipticalRoiViewportTool="?^wvEllipticalRoiViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvHflipViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"hflip"),this._process=function(n){var e=this.onViewportSelected.bind(this);n.enableSelection(e)},this._unprocess=function(n){this.viewports.forEach(function(n){n.disableSelection()})},this.onViewportSelected=function(n){var e=n.getViewport();e.hflip=!e.hflip,n.setViewport(e)},this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this._activateInputs=angular.noop,this._deactivateInputs=angular.noop,this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop}var r={require:"wvHflipViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvHflipViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvHflipViewportTool="?^wvHflipViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvInvertContrastViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){var n=this;e.call(this,"invertContrast"),this._listenViewChange=function(e){e.onParametersResetting(this,function(e){e.invert=n.isActivated})},this._unlistenViewChange=function(n){n.onParametersResetting.close(this)},this._process=function(n){var e=n.getViewport();e.invert=!0,n.setViewport(e)},this._unprocess=function(n){var e=n.getViewport();e.invert=!1,n.setViewport(e)},this._activateInputs=angular.noop,this._deactivateInputs=angular.noop,this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop}var r={require:"wvInvertContrastViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvInvertContrastViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvInvertContrastViewportTool="?^wvInvertContrastViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvLengthMeasureViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"length")}var r={require:"wvLengthMeasureViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvLengthMeasureViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvLengthMeasureViewportTool="?^wvLengthMeasureViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvPanViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(n){e.call(this,"pan"),this._activateInputs=function(e){var t=this,i=$(e.getEnabledElement());i.on("mousedown.pan",function(i){var r=i.pageX,o=i.pageY,a=i.which;$(document).on("mousemove.pan",function(i){n.$apply(function(){var n=i.pageX-r,s=i.pageY-o;r=i.pageX,o=i.pageY,1===a&&t.pan(e,n,s)}),$(document).one("mouseup",function(n){$(document).unbind("mousemove.pan")})})})},this._deactivateInputs=function(n){var e=$(n.getEnabledElement());e.off("mousedown.pan")},this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop,this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this.pan=function(n,e,t){var i=n.getViewport(),r=+i.scale,o=+i.translation.x,a=+i.translation.y;i.translation.x=o+e/r,i.translation.y=a+t/r,n.setViewport(i)}}i.$inject=["$scope"];var r={require:"wvPanViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvPanViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvPanViewportTool="?^wvPanViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvPixelProbeViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"probe")}var r={require:"wvPixelProbeViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvPixelProbeViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvPixelProbeViewportTool="?^wvPixelProbeViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvRectangleRoiViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"rectangleRoi")}var r={require:"wvRectangleRoiViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvRectangleRoiViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvRectangleRoiViewportTool="?^wvRectangleRoiViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvRotateleftViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"rotateLeft"),this._process=function(n){var e=this.onViewportSelected.bind(this);n.enableSelection(e)},this._unprocess=function(n){this.viewports.forEach(function(n){n.disableSelection()})},this.onViewportSelected=function(n){var e=n.getViewport();e.rotation-=90,n.setViewport(e)},this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this._activateInputs=angular.noop,this._deactivateInputs=angular.noop,this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop}var r={require:"wvRotateleftViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvRotateleftViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvRotateleftViewportTool="?^wvRotateleftViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvRotaterightViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"rotateRight"),this._process=function(n){var e=this.onViewportSelected.bind(this);n.enableSelection(e)},this._unprocess=function(n){this.viewports.forEach(function(n){n.disableSelection()})},this.onViewportSelected=function(n){var e=n.getViewport();e.rotation+=90,n.setViewport(e)},this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this._activateInputs=angular.noop,this._deactivateInputs=angular.noop,this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop}var r={require:"wvRotaterightViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvRotaterightViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvRotaterightViewportTool="?^wvRotaterightViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvVflipViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){function n(n){var e=n.getViewport();e.vflip=!e.vflip,n.setViewport(e)}e.call(this,"vflip"),this._process=function(e){var t=n.bind(this);e.enableSelection(t)},this._unprocess=function(n){this.viewports.forEach(function(n){n.disableSelection()})},this._listenViewChange=angular.noop,this._unlistenViewChange=angular.noop,this._activateInputs=angular.noop,this._deactivateInputs=angular.noop,this._listenModelChange=angular.noop,this._unlistenModelChange=angular.noop}var r={require:"wvVflipViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvVflipViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvVflipViewportTool="?^wvVflipViewportTool",n}])}])}(),function(){"use strict";function n(n,e){function t(e,t,i,r){var o=n(i.wvZoomViewportTool);e.$watch(o,function(n){n?r.activate():r.deactivate()})}function i(){e.call(this,"zoom")}var r={require:"wvZoomViewportTool",controller:i,link:t,restrict:"A",scope:!1};return i.prototype=Object.create(e.prototype),i.prototype.constructor=i,r}n.$inject=["$parse","WvBaseTool"],angular.module("webviewer").directive("wvZoomViewportTool",n).config(["$provide",function(n){n.decorator("wvViewportDirective",["$delegate",function(n){var e=n[0];return e.require.wvZoomViewportTool="?^wvZoomViewportTool",n}])}])}(),function(){"use strict";function n(n){function t(e,t,i,r){var o=r.wvSerieId,a=r.wvViewport;r.wvSerieId.getViewport=function(){return a.getModel()},o.onCurrentImageIdChanged(function(n,e,t){if(n){var i=e;a.setImage(n,i).then(function(){t&&t(n)})}else a.clearImage()});var s=n(i.wvSerieId);e.$watch(s,function(n){n?o.setSerie(n):o.clearSerie()});var c=n(i.wvOnSerieChange),l=n(i.wvSerie);o.onSerieChanged(function(n){l&&l.assign&&(l.assign(e,n),c&&c(e,{$serie:n}))}),_.filter(r,function(n,t){var i=_.endsWith(t,"SerieExt");n&&i&&(n.register(o),e.$on("$destroy",function(){n.unregister(o)}))})}var i={require:{wvSerieId:"wvSerieId",wvViewport:"wvViewport"},controller:e,link:t,restrict:"A",scope:!1};return i}function e(n){var e=this;this._serieManager=n,this._serieId=null,this._serie=null,this.onCurrentImageIdChanged=new osimis.Listener,this.onSerieChanged=new osimis.Listener,this.onSerieChanged(function(n,t){if(t&&t.onCurrentImageIdChanged.close(e),n){n.onCurrentImageIdChanged(e,function(n,t){e.onCurrentImageIdChanged.trigger(n,!1,t)});var i=n.getCurrentImageId();e.onCurrentImageIdChanged.trigger(i,!0)}else e.onCurrentImageIdChanged.trigger(null)})}n.$inject=["$parse"],e.$inject=["wvSerieManager"],angular.module("webviewer").directive("wvSerieId",n),e.prototype.getViewport=angular.noop,e.prototype.hasSerie=function(){return!!this._serieId},e.prototype.onSerieChanged=angular.noop,e.prototype.clearSerie=function(){var n=this.serie;this._serieId=null,this._serie=null,this.onSerieChanged.trigger(null,n)},e.prototype.setSerie=function(n){var e=this;return this._serieId=n,this._serie=null,this._serieManager.get(n).then(function(n){var t=e._serie;return e._serie=n,e.onSerieChanged.trigger(n,t),n})},e.prototype.getSerie=function(){return this._serie}}(),function(){"use strict";function n(){function n(n,e,t){}var t={controller:e,link:n,restrict:"A",scope:!1};return t}function e(n,e,t){var i=[];this.register=function(n){i.push(n)},this.unregister=function(n){_.pull(i,n)};var r=$('<div class="wv-draggable-clone"></div>');e.draggable({helper:function(){return r},start:function(n,t){var r=i[0].getSerie();if(r){var o=t.helper;o.data("serie-id",r.id),o.width(e.width()),o.height(e.height())}},zIndex:100})}e.$inject=["$scope","$element","$attrs"],angular.module("webviewer").directive("wvDraggableSerieExt",n).config(["$provide",function(n){n.decorator("wvSerieIdDirective",["$delegate",function(n){var e=n[0];return e.require.wvDraggableSerieExt="?^wvDraggableSerieExt",n}])}])}(),function(){"use strict";function n(){function n(n,e,t,i){}var t={controller:e,link:n,restrict:"A",scope:!1};return t}function e(n,e,t){var i=[];this.register=function(n){i.push(n)},this.unregister=function(n){_.pull(i,n)},t.droppable({accept:"[wv-draggable-serie-ext]",drop:function(t,r){var o=$(r.helper),a=o.data("serie-id");e.$apply(function(){i.forEach(function(e){var t=e.getSerie();t&&n.$emit("UserUnSelectedSeries",t),e.setSerie(a).then(function(e){e&&n.$emit("UserSelectedSeries",e)})})})}})}e.$inject=["$rootScope","$scope","$element"],angular.module("webviewer").directive("wvDroppableSerieExt",n).config(["$provide",function(n){n.decorator("wvSerieIdDirective",["$delegate",function(n){var e=n[0];return e.require.wvDroppableSerieExt="?^wvDroppableSerieExt",n}])}])}(),function(){"use strict";function n(n){function t(e,t,i,r){var o=n(i.wvPlaySerieExt);e.$watch(o,function(n){n?r.activate():r.deactivate()})}var i={require:"wvPlaySerieExt",controller:e,link:t,restrict:"A",scope:!1};return i}function e(n,e,t){var i=this,r=[];this.isActivated=!1,this.register=function(n){r.push(n);var e=n.getSerie();this.isActivated&&e&&this.activate(e),n.onSerieChanged(this,function(n,e){e&&i.isActivated&&i.deactivate(e),n&&i.isActivated&&i.activate(n)})},this.unregister=function(n){_.pull(r,n),n.onSerieChanged.close(this);var e=n.getSerie();this.deactivate(e)},this.activate=function(n){"undefined"==typeof n?(r.forEach(function(n){var e=n.getSerie();i.activate(e)}),this.isActivated=!0):n&&!n.isPlaying&&n.play()},this.deactivate=function(n){"undefined"==typeof n?(r.forEach(function(n){var e=n.getSerie();i.deactivate(e)}),this.isActivated=!1):n&&n.isPlaying&&n.pause()}}n.$inject=["$parse"],e.$inject=["$scope","$element","$attrs"],angular.module("webviewer").directive("wvPlaySerieExt",n).config(["$provide",function(n){n.decorator("wvSerieIdDirective",["$delegate",function(n){var e=n[0];return e.require.wvPlaySerieExt="?^wvPlaySerieExt",n}])}])}(),function(){"use strict";function n(){function n(n,e,t){}var t={controller:e,link:n,restrict:"A",scope:!1};return t}function e(n,e,t){function i(){n.$apply(function(){o.forEach(function(n){var e=n.getSerie();e&&e.play()})})}function r(){n.$apply(function(){o.forEach(function(n){var e=n.getSerie();e&&(e.pause(),e.goToImage(0))})})}var o=[];this.register=function(n){o.push(n)},this.unregister=function(n){_.pull(o,n)},e.on("mouseover",i).on("mouseout",r),n.$on("$destroy",function(){o.forEach(function(n){var e=n.getSerie();e&&e.pause()}),e.off("mouseover",i),e.off("mouseout",r)})}e.$inject=["$scope","$element","$attrs"],angular.module("webviewer").directive("wvScrollOnOverSerieExt",n).config(["$provide",function(n){n.decorator("wvSerieIdDirective",["$delegate",function(n){var e=n[0];return e.require.wvScrollOnOverSerieExt="?^wvScrollOnOverSerieExt",n}])}])}(),function(){"use strict";function n(){function n(n,e,t){}var t={controller:e,link:n,restrict:"A",scope:!1};return t}function e(n,e,t,i){function r(t){function i(i){var r=t.getSerie();if(r){a+=i.distance/20;var o=e.width()/r.imageCount;a>=o&&(n.$apply(function(){i.direction===Hammer.DIRECTION_LEFT?r.goToPreviousImage():i.direction===Hammer.DIRECTION_RIGHT&&r.goToNextImage(!1)}),a%=o),i.isFinal&&(a=0)}}var r=t.getViewport().getEnabledElement(),o=new Hammer(r,{inputClass:Hammer.TouchInput});o.get("pan").set({direction:Hammer.DIRECTION_HORIZONTAL,pointers:1}),s[t]=o,c[t]=i,o.on("pan",c[t]);var a=0}function o(n){var e=s[n];e.off("pan",c[n]),delete s[n]}var a=[];this.register=function(n){a.push(n),r(n)},this.unregister=function(n){_.pull(a,n),o(n)},i=i(e[0]),i.wheel(function(e,t,i,r){n.$apply(function(){a.forEach(function(n){var e=n.getSerie();e&&(0>r?e.goToPreviousImage():r>0&&e.goToNextImage(!1))})}),e.preventDefault()}),n.$on("$destroy",function(){i.unwheel()});var s={},c={}}e.$inject=["$scope","$element","$attrs","hamster"],angular.module("webviewer").directive("wvScrollOnWheelSerieExt",n).config(["$provide",function(n){n.decorator("wvSerieIdDirective",["$delegate",function(n){var e=n[0];return e.require.wvScrollOnWheelSerieExt="?^wvScrollOnWheelSerieExt",n}])}])}(),function(){"use strict";function n(n,t,i,r,o,a,s,c,l){function d(n,e,i,r){function o(n,t){if(!n)return t.resizeCanvas(e.width(),e.height()),null;var i=n&&n.onUpdate(function(){var e=n.getWidthInPixel(),i=n.getHeightInPixel();t.resizeCanvas(e,i)});return function(){i()}}function a(n){t.forEach(r,function(e,i){var r=t.endsWith(i,"ViewportTool");e&&r&&n(e,i)})}var l=e.children("div").children(".wv-cornerstone-enabled-image")[0],d=new osimis.Viewport(c,l,!!n.vm.wvLossless);n.vm.wvEnableOverlay=!!n.vm.wvEnableOverlay;var u=(s(i.wvImageId),r.wvSize),p=o(u,d),f=!1,h=r.wvViewport;h.getImage=function(){return d.getImageId()},h.getModel=function(){return d},h.setImage=function(e,t){return f=!0,n.vm.wvImageId=e,d.setImage(e,t)},h.clearImage=function(){n.vm.wvImageId=null},n.$watch("vm.wvImageId",function(n,e){return f?void(f=!1):void(e&&!n?d.clearImage():n&&d.setImage(n))}),d.onImageChanged(function(e){n.vm.wvImage=e,n.vm.wvOnImageChange&&n.vm.wvOnImageChange({$image:e})}),e.on("CornerstoneImageRendered",function(e,t){n.$evalAsync(function(){n.vm.wvViewport=t.viewport})}),n.$on("$destroy",function(){p&&(p(),p=null),d.destroy()}),d.onImageChanged.once(function(e){a(function(e){e.register(d),n.$on("$destroy",function(){e.unregister(d)})})})}var u={transclude:!0,bindToController:!0,controller:e,controllerAs:"vm",templateUrl:"app/viewport/viewport.directive.html",link:d,restrict:"E",require:{wvViewport:"wvViewport",wvSize:"?wvSize"},scope:{wvImageId:"=?",wvImage:"=?",wvOnImageChange:"&?",wvViewport:"=?",wvEnableOverlay:"=?",wvLossless:"@?"}};return u}function e(n,e,t,i){this.getImage=angular.noop,this.setImage=angular.noop,this.clearImage=angular.noop}n.$inject=["$","_","cornerstone","cornerstoneTools","$rootScope","$q","$parse","wvImageManager","WvImageQualities"],e.$inject=["$scope","$element","cornerstone","wvImageManager"],angular.module("webviewer").directive("wvViewport",n).run(["$q",function(n){osimis.Viewport.$q=n}]).run(["cornerstoneTools",function(n){var e=n.newImageIdSpecificToolStateManager();e.getStateByToolAndImageId=function(n,e){return this.toolState[e]&&this.toolState[e][n]},e.restoreStateByToolAndImageId=function(n,e,t,i){if("undefined"==typeof i&&(i=!0),this.toolState[e]=this.toolState[e]||{},_.merge(this.toolState[e][n],t),i){var r=cornerstone.getEnabledElementsByImageId(e);r.forEach(function(n){var e=n.element;cornerstone.updateImage(e,!0),$(n.element).trigger("CornerstoneImageRendered",{viewport:n.viewport,element:n.element,image:n.image,enabledElement:n,canvasContext:n.canvas.getContext("2d")})})}},n.globalImageIdSpecificToolStateManager=e}])}(),function(n){"use strict";function e(e,t,i){this._imageManager=e,this._enabledElement=t,this._useLosslessByDefault=i,this._inProcessingImageId=null,this._inProcessingImage=null,this._canvasWidth=null,this._canvasHeight=null,this._resolutionScale=null,this._actualImageDisplayer=null,this.onImageChanging=new n.Listener,this.onImageChanged=new n.Listener,this.onParametersResetting=new n.Listener,cornerstone.enable(this._enabledElement)}e.$q=null,e.prototype.destroy=function(){var n=this._actualImageDisplayer;n&&n.destroy(),this.onImageChanged.close(),cornerstone.disable(this._enabledElement)},e.prototype.getEnabledElement=function(){return this._enabledElement},e.prototype.getImage=function(){return this._inProcessingImage},e.prototype.enableSelection=function(n){var e=this;if(this._onViewportSelectedCallback)throw new Error("viewport selection already active");this._onViewportSelectedCallback=function(){n(e)},$(this._enabledElement).on("click",this._onViewportSelectedCallback)},e.prototype.disableSelection=function(){$(this._enabledElement).off("click",this._onViewportSelectedCallback),this._onViewportSelectedCallback=null},e.prototype.getViewport=function(){return cornerstone.getViewport(this._enabledElement)},e.prototype.setViewport=function(n){return cornerstone.setViewport(this._enabledElement,n)},e.prototype.setImage=function(t,i){var r=this;if(i=i||!1,t==this._inProcessingImageId&&!i)throw new Error("This image is already shown");return this._inProcessingImageId=t,i&&this.clearImage(),r._imageManager.get(t).then(function(t){var o=r._actualImageDisplayer,a=o?o._actualResolutionScale:null;o&&(o.destroy(),r._actualImageDisplayer=s);var s=new n.ImageDisplayer(r._canvasWidth,r._canvasHeight,t,a);return r._actualImageDisplayer=s,r._useLosslessByDefault?s.setLosslessQuality():s.setQualityBasedOnCanvasSize(),i&&s.resetParameters(),s.draw(r._enabledElement),s.onImageLoading.once(function(){var n=t,e=r._inProcessingImage;r.onImageChanging.trigger(n,e)}),s.onParametersResetting(function(n){r.onParametersResetting.trigger(n)}),e.$q(function(n,e){s.onImageLoaded.once(function(){var e=t,i=r._inProcessingImage;r._inProcessingImage=e,r.onImageChanged.trigger(e,i),n(t)}),s.onLoadingCancelled.once(function(){e()})})})},e.prototype.clearImage=function(){this._inProcessingImageId=null,$(this._enabledElement).find("canvas").css("visibility","hidden"),this._actualImageDisplayer&&this._actualImageDisplayer.destroy(),this._actualImageDisplayer=null},e.prototype.resizeCanvas=function(n,e){var t=$(this._enabledElement);this._canvasWidth=n,this._canvasHeight=e,t.width(n),t.height(e),cornerstone.resize(this._enabledElement,!1),this._actualImageDisplayer&&this._actualImageDisplayer.resizeCanvas(this._enabledElement,this._canvasWidth,this._canvasHeight)},n.Viewport=e}(window.osimis||(window.osimis={})),angular.module("webviewer").run(["$templateCache",function(n){n.put("app/overlay/droppable-serie-overlay-item.directive.html","<div ng-if=show class=wv-droppable-serie-overlay-item>[ drop a serie here ]</div>"),n.put("app/overlay/loading-bar.directive.html","<svg width=100% height=100% xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><style>\n        .image-bar {\n            cursor: pointer;\n            transition: fill 250ms, transform 250ms;\n        }\n        .not-loaded {\n            fill: rgba(255, 255, 255, 0.1);\n        }\n        .not-loaded, .R150J100-quality {\n            transition: none;\n        }\n        .not-loaded:hover, .active {\n            fill: rgba(255, 255, 255, 0.2);\n        }\n        .LOSSLESS-quality {\n            fill:rgba(0, 255, 0, 0.7);\n        }\n        .LOSSLESS-quality:hover, .LOSSLESS-quality.active {\n            fill:rgba(0, 255, 0, 1);\n        }\n        .R150J100-quality {\n            fill:rgba(255, 0, 0, 0.7);\n        }\n        .R150J100-quality:hover, .R150J100-quality.active {\n            fill:rgba(255, 0, 0, 1);\n        }\n        .R1000J100-quality {\n            fill:rgba(255, 95, 0, 0.7);\n        }\n        .R1000J100-quality:hover, .R1000J100-quality.active {\n            fill:rgba(255, 95, 0, 1);\n        }\n\n        .active {\n            /*transform: rotateZ(5deg);*/\n        }\n    </style><defs><g id=image-loading-bar-{{$id}}><rect ng-attr-width={{vm.imageBarWidth}}% height=100%></rect></g></defs><use xlink:href ng-attr-xlink:href=\"{{'#image-loading-bar-'+$parent.$id}}\" ng-repeat=\"i in [0, vm.imageCount] | range track by $index\" ng-attr-x={{vm.imageBarWidth*i}}% ng-attr-class=\"image-bar {{vm.QualityKeys[vm.bestQualityByImage[i]] ? vm.QualityKeys[vm.bestQualityByImage[i]]+'-quality' : 'not-loaded'}}\" ng-click=vm.serie.goToImage(i) y=2px></use><use xlink:href ng-attr-xlink:href=\"{{'#image-loading-bar-'+$parent.$id}}\" ng-if=vm.imageBarWidth ng-attr-x={{vm.imageBarWidth*vm.currentImageIndex}}% ng-attr-class=\"image-bar {{vm.QualityKeys[vm.bestQualityByImage[vm.currentImageIndex]] ? vm.QualityKeys[vm.bestQualityByImage[vm.currentImageIndex]]+'-quality' : 'not-loaded'}} active\" ng-click=vm.serie.goToImage(vm.currentImageIndex) y=0px></use></svg>"),n.put("app/overlay/overlay.directive.html",'<div class=wv-overlay ng-transclude><div class=wv-overlay-topleft ng-if=vm.showTopLeftArea()>{{vm.wvTags.PatientName}}<br>{{vm.wvTags.PatientID}}</div><div class=wv-overlay-topright ng-if=vm.showTopRightArea()>{{vm.wvTags.StudyDescription}}<br>{{vm.wvTags.StudyDate}}<br>#{{vm.wvTags.SeriesNumber}} - {{vm.wvTags.SeriesDescription}}<br></div><div class=wv-overlay-bottomright ng-if=vm.showBottomRightArea()>zoom: {{vm.wvViewport.scale|number:2}}<br>ww/wc: {{vm.wvViewport.voi.windowWidth|number:0}}/{{vm.wvViewport.voi.windowCenter|number:0}}</div><div style="display:block; position: absolute; right:0; bottom:0; left:0; height: 15px;"><wv-loading-bar wv-serie=vm.wvSerie></wv-loading-bar></div><wv-droppable-serie-overlay-item></wv-droppable-serie-overlay-item></div>'),n.put("app/overlay/scrollbar-overlay-item.directive.html",'<div><div class=wv-overlay-scrollbar-text>{{vm.wvShownImageIndex + 1}}/{{vm.wvImageCount}}<br></div><div class=wv-overlay-scrollbar-loading ng-style="{ right: vm.loadingScrollbarDistanceFromRight }"></div><div class=wv-overlay-scrollbar-loaded ng-style="{ right: vm.loadedScrollbarDistanceFromRight }"></div></div>'),n.put("app/serielist/serielist.directive.html","<ul class={{wvClass.ul}}><li ng-repeat=\"id in serieIds\" class={{wvClass.li}} ng-transclude wv-size-tag><wv-viewport wv-serie-id=id wv-image=$image wv-size=\"{width: '[wv-size-tag]', height: '[wv-size-tag]'}\" wv-draggable-serie-ext wv-scroll-on-over-serie-ext><wv-overlay wv-tags=$image.tags><div class=wv-serielist-overlay>{{$image.tags.SeriesDescription}}</div></wv-overlay></wv-viewport></li></ul>"),n.put("app/splitpane/splitpane.directive.html",'<div class=wv-splitpane><div ng-repeat="$y in y | range track by $index" class=wv-splitpane-row ng-style="{height: rowHeight}"><div ng-repeat="$x in x | range track by $index" class=wv-splitpane-cell ng-style="{width: rowWidth}" wv-size-tag><ng-transclude></ng-transclude><div ng-if=showDefaultContent><wv-viewport wv-serie-id=randomSerieId wv-size="{width: \'[wv-size-tag]\', height:\'[wv-size-tag]\'}" wv-lossless=true wv-droppable-serie-ext wv-scroll-on-wheel-serie-ext wv-enable-overlay="!wvSettings || wvSettings.hasOwnProperty(\'overlay\') == false || wvSettings.overlay" wv-default-viewport-tool=wvSettings.windowing wv-angle-measure-viewport-tool=wvSettings.anglemeasure wv-length-measure-viewport-tool=wvSettings.lengthmeasure wv-elliptical-roi-viewport-tool=wvSettings.ellipticalroi wv-zoom-viewport-tool=wvSettings.zoom wv-pan-viewport-tool=wvSettings.pan wv-pixel-probe-viewport-tool=wvSettings.pixelprobe wv-rectangle-roi-viewport-tool=wvSettings.rectangleroi wv-invert-contrast-viewport-tool=wvSettings.invert wv-play-serie-ext=wvSettings.play wv-rotateright-viewport-tool=wvSettings.rotateright wv-rotateleft-viewport-tool=wvSettings.rotateleft wv-vflip-viewport-tool=wvSettings.vflip wv-hflip-viewport-tool=wvSettings.hflip></wv-viewport></div></div></div></div>'),
n.put("app/toolbar/wv-toolbar-action.tpl.html",'<label class="btn btn-sm btn-default wv-toolbar-item" ng-if=wvItems.hasOwnProperty(wvName) ng-click=wvAction()><span ng-class=wvIcon></span></label>'),n.put("app/toolbar/wv-toolbar-setting.tpl.html",'<button type=button class="btn btn-sm btn-default wv-toolbar-item" html=1 placeholder="<span class=&quot;fa fa-th-large&quot;></span>" icon-checkmark="fa fa-th-large" bs-options="item.value as item.label for item in wvChoices" ng-model=wvItems[wvName] bs-select ng-if=wvItems.hasOwnProperty(wvName)></button>'),n.put("app/toolbar/wv-toolbar-state.tpl.html",'<label class="btn btn-sm btn-default wv-toolbar-item" ng-class="wvIcon || ($parent.$parent.activeStates[wvName] ? wvIconOn : wvIconOff)" ng-if=wvItems.hasOwnProperty(wvName)><input type=checkbox value={{wvName}} style="display: none;" ng-model=$parent.$parent.activeStates[wvName] bs-checkbox></label>'),n.put("app/toolbar/wv-toolbar-tool.tpl.html",'<label class="btn btn-sm btn-default wv-toolbar-item" ng-if=wvItems.hasOwnProperty(wvName)><span ng-class=wvIcon></span> <input type=radio value={{wvName}} style="display: none;" ng-model=$parent.$parent.activeTool bs-radio></label>'),n.put("app/toolbar/wv-toolbar.tpl.html",'<div class="wv-toolbar btn-toolbar" role=toolbar style="margin-left: 0;" ng-transclude ng-init="wvItems = wvItems || $parent.wvItems"><div class=wv-toolbar-settings><wv-toolbar-setting wv-name=layout wv-icon="fa fa-th-large" wv-choices="{ \'1x1\': {x: 1, y: 1}, \'2x1\': {x: 2, y: 1}, \'1x2\': {x: 1, y: 2}, \'2x2\': {x: 2, y: 2} }"></wv-toolbar-setting></div><div class=wv-toolbar-states><wv-toolbar-state wv-name=invert wv-icon="fa fa-adjust"></wv-toolbar-state><wv-toolbar-state wv-name=play wv-icon-on="fa fa-pause" wv-icon-off="fa fa-play"></wv-toolbar-state></div><div class=wv-toolbar-tools><wv-toolbar-tool wv-name=windowing wv-icon="fa fa-sun-o"></wv-toolbar-tool><wv-toolbar-tool wv-name=zoom wv-icon="fa fa-search"></wv-toolbar-tool><wv-toolbar-tool wv-name=pan wv-icon="fa fa-arrows"></wv-toolbar-tool><wv-toolbar-tool wv-name=lengthmeasure wv-icon="fa fa-arrows-v"></wv-toolbar-tool><wv-toolbar-tool wv-name=anglemeasure wv-icon="fa fa-angle-left"></wv-toolbar-tool><wv-toolbar-tool wv-name=pixelprobe wv-icon="fa fa-dot-circle-o"></wv-toolbar-tool><wv-toolbar-tool wv-name=ellipticalroi wv-icon="fa fa-circle-o"></wv-toolbar-tool><wv-toolbar-tool wv-name=rectangleroi wv-icon="fa fa-square-o"></wv-toolbar-tool></div><div class=wv-toolbar-tools><wv-toolbar-tool wv-name=rotateleft wv-icon="fa fa-rotate-left"></wv-toolbar-tool><wv-toolbar-tool wv-name=rotateright wv-icon="fa fa-rotate-right"></wv-toolbar-tool><wv-toolbar-tool wv-name=hflip wv-icon="fa fa-exchange"></wv-toolbar-tool><wv-toolbar-tool wv-name=vflip wv-icon="fa fa-exchange wv-toolbar-icon-rotate-right"></wv-toolbar-tool></div><div class=wv-toolbar-end></div></div>'),n.put("app/viewport/viewport.directive.html",'<div style="position: relative;"><ng-transclude><wv-overlay wv-tags=vm.wvImage.tags wv-viewport=vm.wvViewport ng-if=vm.wvEnableOverlay></wv-overlay></ng-transclude><div class="cornerstone-enabled-image wv-cornerstone-enabled-image" oncontextmenu="return false" unselectable=on onselectstart="return false;" onmousedown="return false;"></div></div>')}]);